### **Часть 1 из 7: Регистрация клиента и привязка к тренеру (Стек: React/TS, Vite, Tailwind CSS, Node.js, PM2, Supabase)**

**Общая философия Кабинета Клиента:** Создать для клиента предельно понятную, отзывчивую и мотивирующую среду, которая работает как часы на мобильном устройстве. Клиент не должен думать, интерфейс должен вести его за руку. Каждое действие должно приносить микро-удовлетворение.

---

#### **Модуль 1: Регистрация и Привязка к тренеру**

**Цель модуля:** Обеспечить безошибочный и понятный процесс входа клиента на платформу и его связи с конкретным тренером, управляя его ожиданиями на каждом шаге.

**Топ-5 ключевых нюансов для разработки:**

*   **Нюанс №1: Валидация кода тренера в реальном времени.**
    *   **Проблема:** Пользователь вводит код, нажимает "Далее", видит ошибку "Неверный код". Он пробует снова, снова ошибка. На третий раз он закрывает сайт и пишет тренеру "у тебя ничего не работает". Конверсия в регистрацию падает, создается негативное первое впечатление.
    *   **Детальное решение (React/TS + Tailwind CSS):**
        1.  Создается компонент `CoachCodeInput.tsx`. Для управления состоянием используются хуки `useState` и `useEffect`. Состояние валидации: `type ValidationState = 'idle' | 'loading' | 'success' | 'error';`.
        2.  Для предотвращения частых запросов используется кастомный хук `useDebounce`, который обновляет "отложенное" значение кода через 500 мс после остановки ввода.
        3.  `useEffect` следит за этим "отложенным" значением и, если оно валидно (например, 6 символов), вызывает асинхронную функцию для запроса на эндпоинт `/api/v1/coaches/validate_code`.
        4.  **Стилизация с Tailwind:**
            *   Поле ввода (`<input>`) будет иметь базовые классы `className="p-2 border rounded-md ..."`. В зависимости от состояния валидации, классы будут меняться динамически: `className={\`...\` \${validationState === 'error' ? 'border-red-500' : 'border-gray-300'}`}`.
            *   Рядом с полем ввода будет условно отрисовываться спиннер (состояние `'loading'`), сделанный на Tailwind-классах (`<div className="animate-spin rounded-full h-5 w-5 border-b-2 border-gray-900"></div>`).
            *   Блок с информацией о тренере (состояние `'success'`) будет сверстан с помощью Flexbox (`<div className="flex items-center mt-2 p-2 bg-green-50 rounded-md">...</div>`), а его появление будет анимировано с помощью `transition` и `opacity` классов Tailwind.
        5.  **Node.js/Supabase:** Логика бэкенда остается прежней — запрос к Supabase (`supabase.from('coaches')...`), возврат JSON.
    *   **Кнопка "Отправить заявку"** в родительском компоненте будет иметь условные классы для стилизации и атрибут `disabled`: `className={\`... \${validationState !== 'success' ? 'bg-gray-400 cursor-not-allowed' : 'bg-blue-600 hover:bg-blue-700'}\`} disabled={validationState !== 'success'}`.
    *   **Важность для MVP:** Это критически важно для снижения количества ошибок при регистрации и повышения конверсии. Убирает "слепую" отправку формы, давая пользователю мгновенную обратную связь.

*   **Нюанс №2: Продуманный "Экран ожидания".**
    *   **Проблема:** Клиент отправил заявку. Его перекидывает на пустую страницу. Он не понимает, что делать дальше.
    *   **Детальное решение (React/TS + Supabase + Tailwind CSS):**
        1.  В таблице `profiles` в Supabase (которая связана с `auth.users`) должно быть поле `approval_status` (типа `enum`: `'pending'`, `'approved'`, `'rejected'`).
        2.  **Роутинг:** В React-приложении, используя `react-router-dom`, создается обертка для приватных роутов (`<PrivateRoute />`). Эта обертка получает данные о пользователе из контекста (например, через `useAuth` хук). Если `auth.user.profile.approval_status === 'pending'`, компонент выполняет `<Navigate to="/pending-approval" replace />`.
        3.  Компонент `PendingApprovalScreen.tsx` будет представлять собой центрированную по вертикали и горизонтали карточку (`<div className="min-h-screen flex items-center justify-center bg-gray-50">...</div>`). Внутри карточки — иконка (например, часы), заголовок (`<h1 className="text-2xl font-bold text-gray-800">...</h1>`) и поясняющий текст (`<p className="mt-2 text-gray-600">...</p>`). Все сверстано на утилитарных классах Tailwind.
    *   **Важность для MVP:** Это профессиональное управление ожиданиями пользователя. Он точно знает, на каком он этапе и что ему делать (или не делать).

*   **Нюанс №3: Право на ошибку — "Отмена заявки".**
    *   **Проблема:** Клиент ввел код друга-тренера вместо своего и оказался в "ловушке" состояния ожидания.
    *   **Детальное решение (React/TS + Tailwind CSS + Node.js):**
        1.  В компоненте `PendingApprovalScreen.tsx` добавляется кнопка (`<button className="mt-4 text-sm text-red-600 hover:underline">...</button>`) "Отменить заявку".
        2.  При нажатии на нее, открывается модальное окно. Модальное окно — это кастомный React-компонент, который условно отрисовывается поверх всего экрана с полупрозрачным фоном (`<div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center">...</div>`). Внутри — карточка с подтверждением и кнопками "Да, отменить" и "Нет".
        3.  При подтверждении, отправляется POST-запрос на `/api/v1/requests/cancel`.
        4.  **Node.js/Supabase:** Логика бэкенда та же — удаление заявки и смена статуса пользователя.
        5.  После успешного ответа, React-хук `navigate` из `react-router-dom` перенаправляет пользователя на главную страницу (`'/'`), где роутер снова проверит его статус и направит на страницу ввода кода.
    *   **Важность для MVP:** Дает пользователю контроль над процессом. Без этой функции одна простая ошибка может навсегда отпугнуть клиента.

*   **Нюанс №4: Мягкий онбординг при первом входе.**
    *   **Проблема:** Тренер одобрил заявку. Клиент заходит и теряется в новом интерфейсе.
    *   **Детальное решение (React/TS + Tailwind CSS):**
        1.  В таблице `profiles` в Supabase есть поле `is_first_login: true`.
        2.  При первом входе клиента со статусом `'approved'`, основной компонент приложения (`App.tsx` или `<Layout />`) это проверяет.
        3.  Если `is_first_login` - `true`, запускается онбординг. Можно использовать легкую библиотеку типа `react-joyride` или `shepherd.js`, которые легко стилизуются под Tailwind. Либо создать кастомное решение: состояние онбординга (например, `step: 1`) хранится в React Context. В зависимости от шага, поверх нужных элементов интерфейса отрисовываются полупрозрачные оверлеи и подсказки, сверстанные на Tailwind (`<div className="absolute ...">...</div>`).
        4.  После завершения или пропуска онбординга, отправляется запрос на бэкенд для установки `is_first_login: false` в Supabase.
    *   **Важность для MVP:** Значительно ускоряет обучение пользователя и повышает вероятность того, что он начнет использовать все функции платформы.

*   **Нюанс №5: Юридическая чистота.**
    *   **Проблема:** Отсутствие явного согласия пользователя на обработку данных — юридический риск.
    *   **Детальное решение (React/TS + Tailwind CSS):**
        1.  На форме регистрации (`SignUpForm.tsx`) создается кастомный компонент `Checkbox.tsx`, стилизованный с Tailwind.
        2.  Рядом с чекбоксами — текст со ссылками (`<a className="text-blue-600 hover:underline" href="/terms">...</a>`). Ссылки ведут на статические страницы внутри React-приложения, сверстанные с помощью Tailwind Typography для красивого отображения текста.
        3.  Состояние чекбоксов хранится в `useState`. Кнопка "Зарегистрироваться" имеет условные классы и атрибут `disabled`: `className={\`... \${!termsAccepted || !policyAccepted ? 'bg-gray-400 cursor-not-allowed' : 'bg-blue-600 hover:bg-blue-700'}\`}`.
        4.  На бэкенде, при получении запроса на регистрацию, обязательно должна быть проверка, что эти флаги (`termsAccepted`, `policyAccepted`) переданы и равны `true`.
    *   **Важность для MVP:** Это абсолютная необходимость для любого публичного сервиса. Защищает и пользователя, и владельца платформы.

---

### **Часть 2 из 7: Главный экран клиента ("Мой план на сегодня")**

**Общая философия:** Предоставить клиенту максимально быстрый и наглядный срез его задач на текущий день, мотивируя к их выполнению. Интерфейс должен быть "чистым", без визуального шума, с четкими призывами к действию.

---

#### **Модуль 2: Главный экран ("Мой план на сегодня")**

**Цель модуля:** Сделать дашборд клиента центральной точкой входа, которая за 3 секунды отвечает на вопрос "Что мне делать сегодня?", и превратить выполнение плана в увлекательный процесс.

**Топ-5 ключевых нюансов для разработки:**

*   **Нюанс №1: Продуманное "пустое состояние".**
    *   **Проблема:** Клиент подключился, но тренер еще не успел назначить ему план. Клиент видит пустой экран, думает, что что-то сломалось или про него забыли.
    *   **Детальное решение (React/TS + Tailwind CSS):**
        1.  Основной компонент дашборда, `Dashboard.tsx`, делает запрос на эндпоинт `/api/v1/client/plan?date=today`. Для управления состоянием запроса используется хук `useQuery` из библиотеки `TanStack Query` (ранее React Query). Это идеальное решение для управления кэшированием, состоянием загрузки и ошибками.
        2.  Если `useQuery` возвращает `isSuccess` и `data` является пустым массивом или `null`, компонент отрисовывает специальный компонент "пустого состояния" `EmptyState.tsx`.
        3.  Компонент `EmptyState.tsx` будет сверстан на Tailwind с использованием Flexbox для центрирования (`<div className="flex flex-col items-center justify-center text-center h-full">...</div>`). Внутри будет SVG-иконка (например, из библиотеки `heroicons`), заголовок (`<h2 className="mt-4 text-xl font-semibold text-gray-700">...</h2>`) "Начнем скоро!" и поддерживающий текст.
        4.  Кнопки-ссылки ("Заполнить профиль", "Посмотреть челленджи") будут стилизованы как `ghost` или `secondary` кнопки (`<Link to="/profile" className="px-4 py-2 mt-4 text-blue-600 border border-blue-600 rounded-md hover:bg-blue-50">...</Link>`).
    *   **Важность для MVP:** Превращает потенциально негативный опыт (ожидание) в позитивный и продуктивный, вовлекая пользователя в другие разделы платформы и показывая, что система работает штатно.

*   **Нюанс №2: Интуитивная навигация по дням.**
    *   **Проблема:** Клиент хочет быстро посмотреть, что он делал вчера, чтобы сравнить, или что его ждет завтра, чтобы спланировать день.
    *   **Детальное решение (React/TS + TanStack Query + Tailwind CSS):**
        1.  В компоненте `Dashboard.tsx` используется `useState` для хранения текущей отображаемой даты: `const [currentDate, setCurrentDate] = useState(new Date())`.
        2.  Ключ запроса для `useQuery` будет зависеть от этой даты: `useQuery({ queryKey: ['plan', currentDate], queryFn: () => fetchPlan(currentDate) })`. `TanStack Query` автоматически будет делать новый запрос и кэшировать результаты, когда `currentDate` меняется.
        3.  Вверху экрана отображается дата. Рядом — кнопки-иконки `<` и `>` (SVG из `heroicons`), обернутые в `<button>`. Их `onClick` будет изменять `currentDate` с помощью `date-fns` или другой библиотеки для работы с датами.
        4.  С помощью Tailwind стилизуем кнопки так, чтобы они были большими и удобными для нажатия на мобильных устройствах (`<button className="p-2 rounded-full hover:bg-gray-100">...</button>`).
        5.  Кнопка "Вернуться к сегодняшнему дню" (`<button className="text-sm text-blue-600 ...">Сегодня</button>`) будет условно отрисовываться, если `currentDate` не является сегодняшним днем.
    *   **Важность для MVP:** Делает дашборд не статичной страницей, а живым календарем, что значительно повышает его полезность и интерактивность.

*   **Нюанс №3: Психология завершенности (визуальное подтверждение).**
    *   **Проблема:** Клиент выполнил тренировку, но в интерфейсе ничего не изменилось. Нет чувства завершенности и удовлетворения.
    *   **Детальное решение (React/TS + Tailwind CSS):**
        1.  Каждый блок на дашборде (например, `WorkoutCard.tsx`) получает из API флаг `is_completed: boolean`.
        2.  Стилизация карточки динамически меняется в зависимости от этого флага. Можно использовать библиотеку `clsx` для удобного объединения классов Tailwind.
        3.  **Пример:** `const cardClasses = clsx('p-4 rounded-lg shadow-md transition-all duration-300', { 'opacity-50 bg-gray-50': is_completed, 'bg-white': !is_completed });`.
        4.  Иконка рядом с заголовком также меняется: если `is_completed`, отрисовывается SVG-иконка зеленой галочки (`CheckCircleIcon`), иначе — иконка цели (`FireIcon`).
        5.  **Анимация:** При изменении состояния (например, после завершения тренировки `TanStack Query` делает ре-фетч данных), переход от яркого состояния к "завершенному" будет плавным благодаря классам `transition-all duration-300` из Tailwind.
    *   **Важность для MVP:** Геймификация на микро-уровне. Превращает выполнение плана из обязанности в приятный процесс вычеркивания дел из списка, что формирует позитивную привычку.

*   **Нюанс №4: Минимизация кликов.**
    *   **Проблема:** Чтобы начать тренировку, клиенту нужно нажать на виджет, перейти на страницу программы, а оттуда уже нажать "Начать". Это лишние шаги, которые снижают вероятность начала действия.
    *   **Детальное решение (React/TS + Tailwind CSS):**
        1.  Компоненты-карточки на дашборде (`WorkoutCard.tsx`, `ChallengeCard.tsx`) должны содержать кнопки прямого действия.
        2.  На `WorkoutCard.tsx` будет большая, контрастная кнопка, стилизованная с помощью Tailwind: `<Link to={\`/workout/\${workoutId}/session\`} className="inline-flex items-center justify-center px-6 py-3 mt-4 font-semibold text-white bg-blue-600 rounded-lg shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500">Начать тренировку</Link>`. Эта ссылка ведет сразу на роут "режима выполнения", минуя все промежуточные страницы.
        3.  На `ChallengeCard.tsx` кнопка "Отчитаться" будет вызывать модальное окно с интерфейсом отчета (камера или чекбокс) прямо поверх дашборда, не уводя пользователя с экрана.
    *   **Важность для MVP:** Уважение ко времени пользователя. Особенно актуально для мобильных устройств, где каждый лишний клик и загрузка страницы раздражают и могут привести к отказу от выполнения задачи.

*   **Нюанс №5: Интерактивный план питания.**
    *   **Проблема:** План питания — это просто текст. Клиент прочитал его и забыл. Нет никакой вовлеченности, и тренер не получает обратной связи.
    *   **Детальное решение (React/TS + Supabase + Tailwind CSS):**
        1.  Компонент `NutritionPlan.tsx` отрисовывает приемы пищи (`meal_type`: 'Завтрак', 'Обед' и т.д.) и список продуктов в каждом.
        2.  Рядом с каждым приемом пищи — кастомный чекбокс, стилизованный на Tailwind.
        3.  Состояние "отмеченности" чекбоксов для текущего дня хранится в отдельной таблице в Supabase, например, `nutrition_log` (`user_id`, `date`, `completed_meals`: `jsonb`).
        4.  При клике на чекбокс, хук `useMutation` из `TanStack Query` отправляет PATCH-запрос на бэкенд для обновления `jsonb` поля. Это происходит оптимистично: UI обновляется мгновенно, и только в случае ошибки откатается назад.
        5.  Это позволяет тренеру (в будущих версиях) видеть статистику, какие приемы пищи клиент пропускает чаще всего. Для MVP это просто повышает вовлеченность клиента.
    *   **Важность для MVP:** Повышает осознанность клиента в следовании плану питания и превращает пассивную информацию в интерактивный инструмент, собирая при этом ценные данные для будущего анализа.

---

### **Часть 3 из 7: Мои Программы и "Режим выполнения"**

**Общая философия:** Превратить просмотр тренировочного плана из пассивного чтения в активный, пошаговый и геймифицированный процесс. Интерфейс должен быть максимально чистым, с крупными элементами управления, чтобы им было удобно пользоваться в условиях спортзала — на ходу, с уставшими руками.

---

#### **Модуль 3: Мои Программы и "Режим выполнения"**

**Цель модуля:** Предоставить клиенту четкий, пошаговый и защищенный от ошибок интерфейс для выполнения тренировок, который автоматически собирает данные для тренера и помогает соблюдать протокол.

**Топ-5 ключевых нюансов для разработки:**

*   **Нюанс №1: Контекстная справка по упражнению.**
    *   **Проблема:** Клиент находится в середине тренировки, в зале, музыка играет, он устал. Он видит название упражнения "Румынская тяга" и не может вспомнить нюансы техники. Ему приходится выходить из приложения, открывать YouTube, искать. Тренировочный ритм сбит.
    *   **Детальное решение (React/TS + Tailwind CSS):**
        1.  В компоненте `WorkoutSession.tsx`, который управляет "режимом выполнения", на экране текущего упражнения (`ExerciseScreen.tsx`) рядом с заголовком (`<h1 className="text-3xl font-bold">...</h1>`) располагается кнопка с иконкой `InformationCircleIcon` из `heroicons`.
        2.  Для управления видимостью модального окна используется простой хук `useState`: `const [isModalOpen, setModalOpen] = useState(false)`.
        3.  При нажатии на кнопку, `isModalOpen` становится `true`, что приводит к условной отрисовке компонента `ExerciseInfoModal.tsx`.
        4.  Компонент модального окна будет сверстан на Tailwind с использованием `fixed inset-0` для фона и `z-index` для позиционирования поверх всего. Анимация появления (например, `scale-up` и `fade-in`) будет реализована через `transition` классы Tailwind и изменение классов при монтировании/размонтировании.
        5.  Внутри модального окна — большой, автоматически проигрывающийся и зацикленный видео-элемент (`<video autoPlay loop muted playsInline>...</video>`), под которым — текстовое описание техники (`<p className="prose">...</p>`, используя плагин `tailwindcss-typography`).
        6.  Важно: при открытии модального окна, основной компонент `WorkoutSession.tsx` должен получить сигнал (через callback-функцию `onModalOpen`), чтобы приостановить активный таймер отдыха.
    *   **Важность для MVP:** Делает платформу самодостаточной. Клиенту не нужно покидать экосистему для получения критически важной информации, что повышает качество тренировки и ценность сервиса.

*   **Нюан-с №2: Умное предзаполнение и ввод данных.**
    *   **Проблема:** Клиент делает 5 подходов жима лежа. Ему приходится каждый раз с нуля вводить на телефоне "50" кг и "10" повторений. Это утомительно и раздражает, особенно когда руки дрожат от усталости.
    *   **Детальное решение (React/TS + Tailwind CSS):**
        1.  Компонент `ExerciseScreen.tsx` хранит в своем состоянии массив выполненных подходов: `const [sets, setSets] = useState([])`.
        2.  Поля ввода (`<input type="number">`) для веса и повторений стилизуются как крупные, легко нажимаемые элементы.
        3.  Значения `placeholder` или `defaultValue` для полей первого подхода берутся из данных, заданных тренером (`exercise.target_reps`).
        4.  После того, как клиент заполнил данные для первого подхода и нажал "✓ Готово", эти данные добавляются в массив `sets`.
        5.  Значения `defaultValue` для полей ВТОРОГО и последующих подходов должны браться из данных ПОСЛЕДНЕГО выполненного подхода (т.е., `sets[sets.length - 1].weight`).
        6.  Таким образом, если вес и повторения не меняются, клиенту вообще не нужно ничего вводить, а просто нажимать "✓ Готово".
    *   **Важность для MVP:** Это колоссальная экономия времени и сил для клиента. Превращает нудный процесс логирования в простое подтверждение, что напрямую влияет на то, будет ли клиент вообще пользоваться этой функцией.

*   **Нюанс №3: Сохранение состояния при сбоях (State Persistence).**
    *   **Проблема:** Клиент на 8-м упражнении из 10. Ему поступает важный звонок, ОС выгружает браузер из памяти. Он возвращается в сервис, а весь прогресс тренировки сброшен. Вероятность, что он начнет все заново, близка к нулю.
    *   **Детальное решение (React/TS):**
        1.  Используется кастомный хук `usePersistentState`, который является оберткой над `useState`, но при каждом изменении значения также записывает его в `localStorage` браузера.
        2.  В компоненте `WorkoutSession.tsx` состояние (индекс текущего упражнения, индекс текущего подхода, массив уже выполненных подходов) хранится с помощью этого хука. Ключ в `localStorage` должен быть уникальным для каждой сессии, например, `workout_session_${workoutId}`.
        3.  При монтировании компонента `WorkoutSession.tsx`, он сначала проверяет `localStorage` на наличие незавершенной сессии.
        4.  Если данные найдены, появляется модальное окно: "Похоже, вы не закончили эту тренировку в прошлый раз. Хотите продолжить?". При согласии, состояние компонента инициализируется данными из `localStorage`. При отказе — данные из `localStorage` очищаются.
        5.  После успешного завершения всей тренировки и отправки отчета на сервер, данные из `localStorage` должны быть обязательно очищены.
    *   **Важность для MVP:** Это защита от фрустрации. Делает продукт надежным и устойчивым к внешним прерываниям, что абсолютно необходимо для мобильного использования.

*   **Нюанс №4: Эмоциональное завершение тренировки.**
    *   **Проблема:** Клиент выполнил последний подход последнего упражнения, нажал "Готово" и его просто выкинуло на главный экран. Нет никакого чувства достижения.
    *   **Детальное решение (React/TS + Tailwind CSS):**
        1.  После выполнения последнего подхода, роутер перенаправляет на специальный экран `WorkoutCompleteScreen.tsx`.
        2.  На этом экране с помощью Tailwind CSS создается праздничный интерфейс: центрированный контейнер, крупный заголовок "Отличная работа, [Имя клиента]!".
        3.  Для анимации можно использовать библиотеку `canvas-confetti` для создания эффекта фейерверка, который запускается при монтировании компонента.
        4.  На сервере создается эндпоинт, который по `workout_log_id` рассчитывает краткую статистику (общий тоннаж, время и т.д.). `WorkoutCompleteScreen.tsx` делает запрос на этот эндпоинт и отображает результаты в виде красивых плашек, сверстанных на Flexbox/Grid.
        5.  Под статистикой — одна большая, заметная кнопка "Вернуться на главный экран", стилизованная как основная CTA-кнопка.
    *   **Важность для MVP:** Закрепляет позитивный опыт. Мозг пользователя получает дофаминовое подкрепление, что мотивирует его возвращаться и тренироваться снова, используя именно ваш сервис.

*   **Нюанс №5: Автоматический и интерактивный таймер отдыха.**
    *   **Проблема:** Клиент должен отдыхать 60 секунд. Он сам засекает время, отвлекается на телефон и в итоге отдыхает 3 минуты, нарушая протокол тренировки.
    *   **Детальное решение (React/TS + Tailwind CSS):**
        1.  Создается отдельный компонент `RestTimer.tsx`. Он получает в `props` длительность отдыха в секундах.
        2.  Внутри используется хук `useEffect` с `setInterval` для обратного отсчета. Оставшееся время хранится в `useState`.
        3.  Визуально таймер представляет собой большой круг (сверстанный с помощью Tailwind-классов `rounded-full`, `border`), который анимированно "заполняется" или "опустошается" по мере истечения времени (можно реализовать через SVG или CSS-градиенты). В центре — крупные цифры оставшегося времени.
        4.  Под таймером — кнопки "+15 сек" и "Пропустить отдых", которые позволяют пользователю управлять процессом.
        5.  Для звукового сигнала по окончании используется Web Audio API. В `useEffect` создается `AudioContext`, и по истечении времени проигрывается короткий, заранее загруженный звуковой файл.
    *   **Важность для MVP:** Повышает качество и эффективность тренировочного процесса. Тренер может быть уверен, что клиент соблюдает режим, а клиент получает удобный встроенный инструмент, который не дает ему отвлекаться.

---

### **Часть 4 из 7: Клиентский модуль "Челленджи"**

**Общая философия:** Превратить одиночные цели в социальное и увлекательное соревнование. Интерфейс должен быть простым, поощрять взаимодействие и давать четкое понимание своего прогресса и прогресса других участников.

---

#### **Модуль 4: Челленджи (Кабинет Клиента)**

**Цель модуля:** Предоставить клиенту простой и мотивирующий интерфейс для участия в групповых активностях, подачи заявок и отслеживания прогресса в реальном времени.

**Топ-5 ключевых нюансов для разработки:**

*   **Нюанс №1: "Социальное доказательство" для повышения конверсии в участие.**
    *   **Проблема:** Клиент заходит в раздел "Доступные челленджи", видит список, но не понимает, какие из них популярны или активны. Ему не хватает мотивации, чтобы присоединиться.
    *   **Детальное решение (React/TS + Supabase + Tailwind CSS):**
        1.  **Бэкенд (Node.js/Supabase):** При запросе списка "открытых" челленджей, для каждого челленджа нужно посчитать количество активных участников. Это можно сделать эффективным запросом в Supabase, используя `.rpc()` для вызова заранее созданной SQL-функции, которая делает `count()` по таблице `challenge_participants`.
        2.  API должен возвращать объект челленджа с дополнительным полем `participants_count`.
        3.  **Фронтенд (React/TS):** Компонент `ChallengeCard.tsx`, который отображает челлендж в списке, будет получать это значение. Под названием челленджа будет отрисовываться небольшой блок, сверстанный с помощью Tailwind: `<div className="flex items-center text-sm text-gray-500 mt-2">...</div>`. Внутри — иконка `UsersIcon` из `heroicons` и текст: **"Уже участвуют: {participants_count} человек"**.
        4.  Дополнительно можно отобразить мини-аватарки первых 3-5 участников в виде "стопки", чтобы сделать это еще более наглядным.
    *   **Важность для MVP:** Это мощный психологический триггер. Люди с большей вероятностью присоединяются к активности, в которой уже кто-то участвует. Это напрямую влияет на вовлеченность в эту ключевую функцию.

*   **Нюанс №2: Прозрачное управление состоянием заявки.**
    *   **Проблема:** Клиент нажал "Подать заявку". Кнопка стала неактивной. Что дальше? Приняли ли его заявку? Отклонили? Он находится в неведении.
    *   **Детальное решение (React/TS + Supabase):**
        1.  **Бэкенд:** В таблице `challenge_participants` должно быть поле `status` (типа `enum`: `'pending'`, `'active'`, `'rejected'`). Когда клиент подает заявку, создается запись с его `user_id`, `challenge_id` и статусом `'pending'`.
        2.  **Фронтенд:** В разделе "Доступные челленджи", если для челленджа есть запись со статусом `'pending'`, кнопка "Подать заявку" заменяется на неактивную плашку: `<div className="px-4 py-2 text-center text-yellow-800 bg-yellow-100 rounded-md">Заявка отправлена</div>`.
        3.  Во вкладке **"Мои челленджи"** этот челлендж должен появиться сразу, но в особом "ожидающем" состоянии. Его карточка может быть полупрозрачной и иметь пометку "Ожидает подтверждения от тренера".
        4.  Когда тренер меняет статус на `'active'` или `'rejected'`, **Supabase Realtime** (подписка на изменения в таблице) может отправить событие клиенту, и его UI обновится автоматически, без перезагрузки страницы, показав либо полный доступ к челленджу, либо уведомление об отклонении.
    *   **Важность для MVP:** Обеспечивает полную прозрачность процесса для клиента. Он всегда знает, на каком этапе находится его заявка, что снижает неопределенность и повышает доверие к платформе.

*   **Нюанс №3: Максимально простой и быстрый процесс отчета.**
    *   **Проблема:** Чтобы отчитаться, клиенту нужно сделать 3-4 клика: зайти в челлендж, найти кнопку "отчет", перейти на новую страницу. Это слишком сложно, и многие будут пропускать отчеты.
    *   **Детальное решение (React/TS + Tailwind CSS):**
        1.  На странице активного челленджа (`ActiveChallenge.tsx`) должен быть большой, заметный, всегда видимый блок "Задание на сегодня".
        2.  В этом блоке — одна единственная кнопка **"Отчитаться за сегодня"**, стилизованная как основная CTA-кнопка (`<button className="w-full ... bg-green-600 ...">...</button>`).
        3.  Нажатие на эту кнопку **не должно вести на новую страницу**. Вместо этого, оно должно открывать **модальное окно** поверх текущего экрана.
        4.  Если тип отчета — чекбокс, в модальном окне будет просто большая кнопка "Я выполнил(а)".
        5.  Если тип отчета — фото, в модальном окне будет две кнопки: "Сделать фото" (которая через `input type="file" accept="image/*" capture`) сразу открывает камеру) и "Выбрать из галереи".
        6.  После успешной загрузки фото или нажатия на чекбокс, модальное окно закрывается, а кнопка "Отчитаться за сегодня" заменяется на зеленую плашку "Отчет за сегодня принят!".
    *   **Важность для MVP:** Снижение "трения" в основном действии. Чем проще отчитаться, тем выше будет процент выполнения заданий, и тем успешнее будет весь челлендж.

*   **Нюанс №4: Геймификация и вовлечение в общую ленту.**
    *   **Проблема:** Лента отчетов, где просто идут фотографии одна за другой, может быть скучной и не мотивировать к взаимодействию.
    *   **Детальное решение (React/TS + Supabase + Tailwind CSS):**
        1.  **Реакции:** Под каждым отчетом в ленте (компонент `ReportCard.tsx`) должен быть блок с иконками-реакциями (например, 👍, 🔥, 💪 из `heroicons`). В Supabase создается таблица `report_reactions` (`report_id`, `user_id`, `reaction_type`). При клике на реакцию, с помощью `useMutation` из `TanStack Query` отправляется запрос на добавление/удаление записи. UI обновляется оптимистично.
        2.  **Счетчик реакций:** Рядом с каждой иконкой отображается счетчик, который берется из агрегированного запроса к `report_reactions`.
        3.  **Система "Streak" (серия):** В компоненте, который отрисовывает карточку участника, нужно показывать его текущую серию. На бэкенде пишется SQL-функция в Supabase, которая по `user_id` и `challenge_id` считает, сколько последних дней подряд у пользователя есть отчеты. Это значение (`streak_count`) передается на фронтенд. Рядом с аватаром участника отрисовывается иконка 🔥 и это число.
    *   **Важность для MVP:** Эти простые элементы геймификации превращают пассивное наблюдение в активное участие. Реакции создают социальные связи, а "стрики" мотивируют не пропускать дни, что является ключевым фактором успеха любого челленджа.

*   **Нюанс №5: Постоянный доступ к правилам и цели.**
    *   **Проблема:** Клиент присоединился к челленджу, а через неделю забыл точные правила или главную цель. Ему приходится искать эту информацию или спрашивать у тренера.
    *   **Детальное решение (React/TS + Tailwind CSS):**
        1.  На главной странице челленджа (`ActiveChallenge.tsx`) должен быть "прилипающий" (sticky) или "закрепленный" (pinned) блок, который всегда остается вверху экрана, даже при прокрутке ленты.
        2.  Этот блок (`ChallengeHeader.tsx`) будет сверстан с помощью Tailwind-классов `sticky top-0 bg-white z-10 shadow-sm`.
        3.  Внутри этого блока — название челленджа и кнопка/ссылка "Правила и описание".
        4.  При нажатии на эту кнопку, открывается модальное окно, где красиво (с помощью плагина `@tailwindcss/typography`) отформатирован полный текст описания и правил, которые тренер ввел при создании челленджа.
    *   **Важность для MVP:** Обеспечивает легкий доступ к ключевой информации. Снижает количество однотипных вопросов тренеру и помогает участникам оставаться сфокусированными на цели челленджа.

---

### **Часть 5 из 7: Чат (Кабинет Клиента и Тренера)**

**Общая философия:** Создать надежный, быстрый и функциональный канал для персональной коммуникации, который полностью заменяет тренеру необходимость использовать личные мессенджеры для работы. Чат должен ощущаться "живым", мгновенным и обладать всеми привычными пользователю функциями.

---

#### **Модуль 5: Чат (общая спецификация для обоих кабинетов)**

**Цель модуля:** Реализовать real-time чат на базе WebSockets, который будет стабильно работать даже при плохом соединении, обеспечивать прозрачность статусов сообщений и поддерживать обмен медиафайлами.

**Технический стек:** `Socket.IO` (или нативный WebSocket API + кастомная логика) на стороне клиента (React/TS) и сервера (Node.js). Supabase будет использоваться для хранения истории сообщений и для Realtime-подписки в качестве фолбэка или дополнительного механизма.

**Топ-5 ключевых нюансов для разработки:**

*   **Нюанс №1: Бесшовная работа при обрывах связи и "оптимистичный" UI.**
    *   **Проблема:** Пользователь едет в метро, интернет пропадает. Он пишет длинное сообщение, нажимает "Отправить" — и сообщение просто исчезает с ошибкой. Это вызывает ярость и потерю данных.
    *   **Детальное решение (React/TS + Socket.IO):**
        1.  **Оптимистичное обновление:** Когда пользователь нажимает "Отправить", мы **не ждем ответа от сервера**. Сообщение немедленно добавляется в локальное состояние (например, в массив сообщений в `useState` или `Zustand`/`Redux Toolkit`). Этому сообщению присваивается временный ID (например, с помощью `uuid`) и статус `'sending'`.
        2.  **Визуализация статуса:** В компоненте `Message.tsx`, который отрисовывает сообщение, в зависимости от статуса рядом с временем будет иконка: `sending` -> часики, `sent` -> одна галочка, `read` -> две галочки. Стилизуется на Tailwind.
        3.  **Фоновая отправка:** Одновременно, кастомный хук `useChat` (или сервис) пытается отправить это сообщение через `socket.emit('sendMessage', { tempId, text, ... })`.
        4.  **Подтверждение от сервера:** Сервер, получив сообщение, сохраняет его в Supabase, генерирует постоянный ID, и отправляет обратно подтверждение: `socket.emit('messageSent', { tempId, permanentId, timestamp })`. Клиент, получив это событие, находит сообщение по `tempId` в своем локальном состоянии, заменяет его `id` на постоянный и меняет статус на `'sent'`.
        5.  **Обработка ошибок:** Если сокет не подключен, сервис отправки сообщений не выдает ошибку, а складывает "неотправленные" сообщения в очередь. `Socket.IO` клиент будет автоматически пытаться переподключиться. После успешного переподключения (`socket.on('connect', ...)`), сервис проходит по очереди и отправляет все "зависшие" сообщения.
    *   **Важность для MVP:** Это стандарт работы для любого современного мессенджера (Telegram, WhatsApp). Пользователи ожидают такого поведения. Его отсутствие будет воспринято как баг и ненадежность.

*   **Нюанс №2: Статусы сообщений ("Доставлено" / "Просмотрено").**
    *   **Проблема:** Тренер отправил важное сообщение. Он не знает, увидел его клиент или нет. Он начинает нервничать и дублировать сообщение в другие мессенджеры, что убивает всю идею платформы.
    *   **Детальное решение (Node.js + Supabase + React/TS):**
        1.  **Бэкенд:** В таблице `messages` в Supabase должны быть поля `is_delivered: boolean` и `is_read: boolean`.
        2.  **Логика "Доставлено":** Когда сервер отправляет сообщение пользователю B через WebSocket, и если пользователь B в данный момент онлайн (имеет активное сокет-соединение), сервер сразу помечает сообщение как `is_delivered = true` и отправляет событие `messageDelivered` отправителю A. Если пользователь B офлайн, сообщение помечается как доставленное, когда он в следующий раз подключится и получит "пачку" пропущенных сообщений.
        3.  **Логика "Просмотрено":** В React-компоненте чата используется хук `useEffect` и `Intersection Observer API` для отслеживания, какие сообщения в данный момент видимы на экране пользователя. Когда новые (непрочитанные) сообщения попадают в область видимости, фронтенд собирает их ID и отправляет на сервер одно событие `socket.emit('messagesRead', { ids: [...] })`.
        4.  Сервер, получив это событие, обновляет в Supabase `is_read = true` для всех этих сообщений и рассылает событие `messagesUpdated` отправителю, чтобы у него галочки окрасились.
    *   **Важность для MVP:** Критически важная функция для снижения тревожности и неопределенности в коммуникации.

*   **Нюанс №3: Контекстные ответы (Reply).**
    *   **Проблема:** В чате обсуждается 5 разных тем. Клиент пишет "да". Тренер не понимает, на какой из его пяти вопросов это ответ.
    *   **Детальное решение (React/TS + Supabase + Tailwind CSS):**
        1.  **UI/UX:** При долгом нажатии на мобильном устройстве или наведении на десктопе, у компонента `Message.tsx` появляется кнопка "Ответить".
        2.  При нажатии на нее, в состоянии компонента чата (`Chat.tsx`) сохраняется ID сообщения, на которое отвечают. Над полем ввода (`<textarea>`) появляется небольшая плашка с текстом цитируемого сообщения.
        3.  **Бэкенд:** При отправке нового сообщения, в его объекте передается поле `reply_to_message_id`. В Supabase, в таблице `messages` создается соответствующее поле (foreign key на саму себя).
        4.  **Отрисовка:** Компонент `Message.tsx`, если у сообщения есть `reply_to_message_id`, отрисовывает над текстом небольшой блок-цитату. Эта цитата — это отдельный компонент `QuotedMessage.tsx`, который получает данные о цитируемом сообщении. Клик по этому блоку должен плавно прокручивать чат к исходному сообщению (для этого используется `ref` и `element.scrollIntoView({ behavior: 'smooth' })`).
    *   **Важность для MVP:** Вносит порядок в асинхронное общение. Без этой функции любой чат с более чем 10 сообщениями превращается в хаос.

*   **Нюанс №4: "Односторонняя" коммуникация (Объявления).**
    *   **Проблема:** Тренер хочет сообщить всем 50 клиентам, что уезжает в отпуск. Создавать групповой чат — плохая идея, так как начнется флуд. Писать каждому — долго.
    *   **Детальное решение (React/TS + Node.js + Supabase):**
        1.  **UI тренера:** В интерфейсе чата у тренера есть специальный, всегда "пришпиленный" вверху диалог `Announcements.tsx` ("Объявления для клиентов").
        2.  **Бэкенд:** Когда тренер пишет в этот чат, Node.js сервер не создает обычное сообщение. Он получает текст, `sender_id` (тренера) и список всех его активных `client_id`. Затем он в цикле создает записи в таблице `messages` для каждого клиента, но с особым флагом `is_announcement: true`.
        3.  **UI клиента:** Компонент `Message.tsx`, если видит флаг `is_announcement`, может стилизовать сообщение иначе (например, добавить иконку рупора 📢, другой фон). Важно: для таких сообщений нужно скрыть возможность "Ответить". У клиента в списке диалогов это будет выглядеть как обычный чат с тренером, он не будет видеть отдельного канала "Объявления".
    *   **Важность для MVP:** Мощный инструмент для массовой, но при этом персональной коммуникации. Решает реальную бизнес-задачу тренера, экономя ему массу времени.

*   **Нюанс №5: Оптимизация загрузки медиафайлов.**
    *   **Проблема:** Клиент записал видео своей техники на 200 МБ в 4К и пытается загрузить его в чат. Это надолго "вешает" интерфейс, тратит кучу мобильного трафика и забивает ваше хранилище Supabase Storage.
    *   **Детальное решение (React/TS + Supabase Storage):**
        1.  **Ограничение на клиенте:** `input type="file"` будет иметь атрибут `accept="image/*,video/mp4,video/quicktime"`.
        2.  **Предварительная обработка:** Перед загрузкой, JavaScript на клиенте должен проверять размер файла. Если он превышает лимит (например, 50 МБ), пользователю выводится ошибка. Для изображений используется библиотека `browser-image-compression` для сжатия до адекватных размеров (например, 1920px по большей стороне) и качества.
        3.  **Загрузка в Supabase Storage:** Файл загружается не на ваш Node.js сервер, а напрямую из браузера в Supabase Storage. Ваш бэкенд должен сначала сгенерировать "signed upload URL" — временную безопасную ссылку для загрузки, и передать ее клиенту. Клиент использует эту ссылку для загрузки файла.
        4.  **UI:** Во время загрузки в чате отображается превью изображения/видео с полупрозрачным оверлеем и прогресс-баром (или спиннером), реализованным на Tailwind.
        5.  После успешной загрузки, клиент отправляет в чат сообщение типа `media` со ссылкой на загруженный файл в Supabase Storage.
    *   **Важность для MVP:** Обеспечивает стабильность работы платформы и контроль над расходами на хранение данных. Прямая загрузка в Storage — это правильный и масштабируемый архитектурный подход.

---

### **Часть 6 из 7: Кабинет тренера: Управление клиентами (CRM)**

**Общая философия:** Предоставить тренеру сверхэффективный "командный центр", который минимизирует рутинные операции, автоматизирует сбор данных и позволяет управлять большим количеством клиентов, уделяя каждому персональное внимание. Интерфейс должен быть оптимизирован для ПК и планшетов, быть "плотным" по данным, но не перегруженным.

---

#### **Модуль 6: Клиенты (Управление заявками и базой)**

**Цель модуля:** Дать тренеру гибкие инструменты для управления жизненным циклом клиента: от обработки заявки до архивации профиля, с возможностью быстрой сегментации, поиска и мгновенного доступа к ключевой информации.

**Топ-5 ключевых нюансов для разработки:**

*   **Нюанс №1: Четкое разделение потоков (входящий vs. исходящий).**
    *   **Проблема:** В одном интерфейсе смешаны функции приглашения и обработки заявок. Тренер может запутаться, какой процесс сейчас активен. Это создает когнитивную нагрузку.
    *   **Детальное решение (React/TS + Tailwind CSS):**
        1.  В основном компоненте раздела `ClientsPage.tsx` создается компонент-таб `Tabs.tsx`. Он будет управлять состоянием активной вкладки.
        2.  Вкладки будут стилизованы с помощью Tailwind: активная вкладка будет иметь яркий нижний бордер и более насыщенный цвет текста (`border-b-2 border-blue-600 text-blue-600`), неактивные — нейтральные (`border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300`).
        3.  Будет две вкладки: **"Мои клиенты"** (открыта по умолчанию) и **"Заявки на подключение"**. Рядом с названием второй вкладки будет рендериться небольшой значок-бейдж (`<span className="ml-2 px-2 py-0.5 text-xs font-semibold text-white bg-blue-600 rounded-full">...</span>`) с количеством ожидающих заявок, если оно больше нуля.
        4.  Кнопка **"Пригласить клиента"** будет расположена отдельно, в шапке страницы, и будет всегда видна, вне зависимости от активной вкладки. Нажатие на нее открывает модальное окно с генерацией ссылки-приглашения.
    *   **Важность для MVP:** Структурирует работу тренера. Он четко понимает, где искать существующих клиентов и где обрабатывать новых. Это базовый принцип хорошего UX в сложных интерфейсах.

*   **Нюанс №2: Продуманный процесс отказа и принятия заявки.**
    *   **Проблема:** Тренер нажимает "Отклонить". Заявка просто исчезает. Клиент на своей стороне продолжает видеть "Ожидает подтверждения". Или тренер нажимает "Принять", и ничего не происходит, диалог не начат.
    *   **Детальное решение (React/TS + Node.js + Supabase):**
        1.  **Отклонение:** При нажатии кнопки "Отклонить" на карточке заявки, отправляется запрос на бэкенд. Node.js меняет статус клиента в таблице `profiles` на `'rejected'`. Клиент, зайдя в свой кабинет, увидит соответствующий экран (как было описано в Части 1). Для тренера заявка просто пропадает из списка.
        2.  **Принятие:** При нажатии кнопки "Принять", происходит несколько действий в одной транзакции на бэкенде:
            *   Статус клиента в `profiles` меняется на `'approved'`.
            *   В таблице `client_coach_relations` создается связь между `client_id` и `coach_id`.
        3.  **UI-отклик:** После успешного ответа от сервера, React (с помощью `TanStack Query`) инвалидирует кэш списка заявок (чтобы отклоненная/принятая заявка исчезла) и списка клиентов (чтобы новый клиент там появился).
        4.  В правом нижнем углу экрана тренера появляется всплывающее уведомление (toast), сверстанное на Tailwind: "Клиент [Имя клиента] успешно добавлен!". В этом уведомлении есть две кнопки-ссылки: **"Назначить программу"** (`<Link to=... />`) и **"Написать приветствие"** (`<button onClick=... />`). Вторая кнопка открывает модальное окно с чатом.
    *   **Важность для MVP:** Завершает коммуникационную петлю и подталкивает тренера к немедленному действию, ускоряя онбординг нового клиента.

*   **Нюанс №3: Мощная фильтрация и тегирование.**
    *   **Проблема:** У тренера 50+ клиентов. Ему нужно быстро найти всех новичков, или всех, кто готовится к соревнованиям. Прокручивать бесконечный список или использовать Ctrl+F — неэффективно.
    *   **Детальное решение (React/TS + Supabase + Tailwind CSS):**
        1.  **Бэкенд:** В Supabase создаются таблицы `tags` (`id`, `coach_id`, `name`) и `client_tags` (`client_id`, `tag_id`).
        2.  **UI Карточки клиента:** В профиле клиента (`ClientProfile.tsx`) есть раздел "Теги". Это поле ввода с автодополнением, которое ищет по существующим тегам тренера или позволяет создать новый "на лету". Присвоенные теги отображаются как цветные плашки.
        3.  **UI Панели фильтров:** На странице `ClientsPage.tsx`, над списком клиентов, располагается `FiltersPanel.tsx`. Она содержит:
            *   Поле поиска (`<input type="search">`).
            *   Выпадающий список для фильтрации по статусу ("Активные", "Архивные").
            *   Мультиселект-компонент для фильтрации по тегам (можно использовать headless-библиотеку типа `Downshift` или `Headless UI` и стилизовать ее с Tailwind).
        4.  **Логика:** Состояние фильтров хранится в `useState`. При изменении любого фильтра (с использованием `debounce` для поля поиска), `TanStack Query` делает новый запрос на бэкенд, передавая параметры фильтрации в URL (`/api/v1/clients?search=...&status=...&tags=1,2,3`). Node.js строит соответствующий сложный запрос к Supabase.
    *   **Важность для MVP:** Это профессиональный CRM-инструмент. Позволяет тренеру эффективно сегментировать свою базу и работать с группами клиентов, а не только индивидуально, что критически важно при масштабировании.

*   **Нюанс №4: Безопасное архивирование вместо удаления.**
    *   **Проблема:** Тренер хочет убрать из списка клиента, который ушел, и нажимает "Удалить". Данные о его прогрессе, программы, история чатов — все теряется безвозвратно. Через год клиент возвращается, и всю историю приходится собирать заново.
    *   **Детальное решение (React/TS + Supabase + Tailwind CSS):**
        1.  В интерфейсе (например, в выпадающем меню "действия" на карточке клиента) **нет кнопки "Удалить"**. Вместо нее — кнопка **"Архивировать"**.
        2.  При нажатии на нее, отправляется PATCH-запрос на бэкенд, который меняет `status` клиента в таблице `profiles` на `'archived'`.
        3.  Список клиентов по умолчанию запрашивает с бэкенда только тех, у кого `status = 'active'`. Заархивированный клиент просто пропадает из основного списка.
        4.  В панели фильтров есть возможность выбрать статус "Архивные". При этом выборе, отображается список заархивированных клиентов.
        5.  В карточке заархивированного клиента кнопка "Архивировать" заменена на "Восстановить", которая меняет статус обратно на `'active'`.
        6.  Настоящее удаление данных (в соответствии с GDPR) может быть скрыто в настройках профиля и требовать нескольких подтверждений, либо осуществляться только через поддержку.
    *   **Важность для MVP:** Сохраняет ценные данные. История работы с клиентом — это актив тренера. Платформа должна оберегать этот актив и защищать тренера от случайных ошибок.

*   **Нюанс №5: "Птичий глаз" — информативный список клиентов.**
    *   **Проблема:** Список клиентов — это просто таблица с именами. Чтобы узнать что-то важное (есть ли новые сообщения, просрочена ли оплата), нужно заходить в каждую карточку.
    *   **Детальное решение (React/TS + Supabase + Tailwind CSS):**
        1.  **Бэкенд:** Запрос на получение списка клиентов должен быть обогащенным. С помощью JOIN'ов или SQL-функций в Supabase, для каждого клиента нужно посчитать количество непрочитанных сообщений и получить дату следующего платежа (которую тренер вносит вручную).
        2.  **UI:** Компонент, отображающий одну строку/карточку клиента в списке (`ClientListItem.tsx`), будет показывать не только аватар и имя, но и несколько иконок-индикаторов:
            *   Если `unread_messages_count > 0`, показывать бейдж с этим числом (`<span className="... bg-red-500 ...">{count}</span>`).
            *   Если `next_payment_date` просрочен, показывать иконку-предупреждение (`ExclamationCircleIcon` из `heroicons` красного цвета) со всплывающей подсказкой "Просрочена оплата".
            *   Показывать последнюю активность клиента: "Последняя тренировка: вчера".
        3.  Вся строка должна быть кликабельной и вести на страницу профиля клиента (`<Link to={\`/clients/\${clientId}\`}>...</Link>`).
    *   **Важность для MVP:** Превращает список клиентов из пассивного справочника в активную приборную панель. Тренер может одним взглядом оценить состояние дел по всей своей базе и быстро определить, кто требует его внимания прямо сейчас.

---

### **Часть 7 из 7: Кабинет тренера: Конструкторы, Дашборд и Челленджи**

**Общая философия:** Предоставить тренеру сверхэффективный "командный центр", который минимизирует рутинные операции, автоматизирует сбор данных и позволяет управлять большим количеством клиентов, уделяя каждому персональное внимание. Интерфейс должен быть оптимизирован для ПК и планшетов, быть "плотным" по данным, но не перегруженным.

---

#### **Модуль 7: Конструктор программ**

**Цель модуля:** Дать тренеру мощный и гибкий инструмент, который превращает рутинный процесс составления планов из "копипасты в Excel" в быстрый, творческий и безошибочный процесс, с возможностью переиспользования наработок.

**Топ-5 ключевых нюансов для разработки:**

*   **Нюанс №1: Четкое разделение Глобальной и Личной библиотеки упражнений.**
    *   **Проблема:** Тренер хочет добавить свое специфическое упражнение "Тяга Свенда с блином 1.25 кг". Если он добавит его в общую базу, она быстро засорится тысячами узкоспециализированных или дублирующихся упражнений.
    *   **Детальное решение (React/TS + Supabase + Tailwind CSS):**
        1.  **Бэкенд:** В Supabase таблица `exercises` должна иметь поле `coach_id` (nullable foreign key к `coaches`). Если `coach_id` равно `NULL`, это системное упражнение. Иначе — личное.
        2.  **UI:** В интерфейсе конструктора программ, при выборе упражнений (например, в модальном окне `ExercisePicker.tsx`), будут две вкладки: "База платформы" и "Мои упражнения".
        3.  "База платформы" делает запрос `/api/v1/exercises?scope=system`.
        4.  "Мои упражнения" делает запрос `/api/v1/exercises?scope=personal`. Здесь же есть кнопка "Создать упражнение", которая открывает форму и при сохранении отправляет `coach_id` на бэкенд.
    *   **Важность для MVP:** Фундаментальное архитектурное решение, обеспечивающее порядок и масштабируемость контента. Позволяет сочетать стандартизацию и персонализацию.

*   **Нюанс №2: Независимость клиентской программы от шаблона.**
    *   **Проблема:** Тренер создал шаблон "День ног", назначил его 10 клиентам, а потом изменил упражнение в шаблоне. Изменение применилось ко всем, что является катастрофой.
    *   **Детальное решение (Node.js + Supabase):**
        1.  На бэкенде должны быть две разные таблицы: `program_templates` и `client_programs`. Структура у них может быть очень похожей.
        2.  Когда тренер нажимает "Назначить программу клиенту", его фронтенд отправляет запрос на специальный эндпоинт, например, POST `/api/v1/client-programs`.
        3.  Node.js сервер, получив `template_id` и `client_id`, выполняет в Supabase транзакцию (через `.rpc()` вызов SQL-функции):
            *   Читает все данные из `program_templates` и связанных с ней таблиц упражнений.
            *   Создает новую запись в `client_programs`.
            *   Копирует все упражнения, подходы и т.д. в связанные таблицы, но уже с `client_program_id`.
    *   **Важность для MVP:** Обеспечивает целостность данных и предсказуемость работы системы. Без этого нюанса работа с шаблонами становится опасной и бессмысленной.

*   **Нюанс №3: Поддержка сложных протоколов (Суперсеты/Трисеты).**
    *   **Проблема:** Тренер хочет, чтобы клиент делал подтягивания и сразу после них, без отдыха, отжимания. В простом линейном списке упражнений это никак не отобразить.
    *   **Детальное решение (React/TS + Supabase + Tailwind CSS):**
        1.  **Бэкенд:** В таблице, которая связывает упражнения с программой (например, `program_exercises`), нужно добавить поле `superset_group` (тип `integer`). У обычных упражнений оно `NULL`. У упражнений в первом суперсете оно равно `1`, во втором — `2`, и так далее.
        2.  **UI Конструктора:** В React-компоненте конструктора, сверстанном с Tailwind, используется библиотека для drag-and-drop (например, `dnd-kit`). Тренер может перетаскивать упражнения. Появляется специальная "зона для суперсета", при перетаскивании в которую упражнениям присваивается `superset_group`. Визуально они объединяются общей рамкой (`border rounded-md p-2`).
        3.  **UI Клиента:** В "режиме выполнения" логика меняется: если у текущего упражнения `superset_group` не `NULL`, то после его выполнения система ищет следующее упражнение с тем же `superset_group` и показывает его, пропуская таймер отдыха.
    *   **Важность для MVP:** Значительно расширяет арсенал тренера. Позволяет создавать не только простые, но и продвинутые, более эффективные тренировочные программы.

#### **Модуль 8: Управление Челленджами (Кабинет Тренера)**

*   **Нюанс №4: Гибкий "Тип доступа" и управление заявками.**
    *   **Проблема:** Тренер хочет создать челлендж только для своей "продвинутой" группы, но при этом другой, для новичков, сделать открытым для всех.
    *   **Детальное решение (React/TS + Supabase + Tailwind CSS):**
        1.  **Бэкенд:** В таблице `challenges` в Supabase добавляется поле `access_type` (enum: `'private'`, `'public'`).
        2.  **UI Создания:** В форме создания челленджа (`CreateChallengeForm.tsx`) есть компонент-переключатель (radio buttons), стилизованный с Tailwind, где тренер выбирает "Приватный (только по приглашению)" или "Открытый (по заявкам)".
        3.  **UI Управления:** В интерфейсе управления челленджем (`ChallengeManagement.tsx`), если `access_type === 'public'`, появляется вкладка **"Заявки"**.
        4.  На этой вкладке отображается список заявок (статус `'pending'` из `challenge_participants`). Тренер может массово (через чекбоксы) или по одной принимать/отклонять заявки. Это меняет статус участника на `'active'` или удаляет запись. Используется `TanStack Query` `useMutation` для обновления данных с автоматической инвалидацией кеша списка заявок.
    *   **Важность для MVP:** Дает тренеру полный контроль над формированием групп и делает челленджи гибким инструментом как для массового вовлечения, так и для эксклюзивной работы.

#### **Модуль 9: Дашборд Тренера**

*   **Нюанс №5: "Живая" и контекстная приборная панель.**
    *   **Проблема:** Дашборд показывает статичную информацию. Он полезен, но не создает ощущения "пульса" работы.
    *   **Детальное решение (React/TS + Supabase Realtime + Tailwind CSS):**
        1.  **Realtime-подписки:** Основной компонент дашборда (`Dashboard.tsx`) при монтировании подписывается на изменения в нескольких таблицах Supabase с помощью `Supabase.js` клиента:
            *   Подписка на новые записи в `requests` (новые клиенты).
            *   Подписка на новые записи в `challenge_participants` со статусом `'pending'`.
            *   Подписка на новые сообщения в `messages`, где получатель — тренер.
        2.  **UI-отклик:** При получении нового события (например, новой заявки), `TanStack Query` можно настроить так, чтобы он автоматически делал ре-фетч нужных данных. Либо можно вручную обновить состояние. На иконке-уведомлении или на вкладке в браузере (favicon) может появиться индикатор.
        3.  **Контекстные действия:** Уведомления на дашборде — это не просто текст. Это интерактивные компоненты. Например, уведомление "Новая заявка от Ивана Петрова" имеет кнопки "Принять"/"Отклонить" прямо в себе. Нажатие на них выполняет действие, не покидая дашборд. Это делается через `useMutation` и отправку запроса на бэкенд.
    *   **Важность для MVP:** Превращает дашборд из статического отчета в живой, дышащий командный центр. Тренер может выполнять ключевые операционные задачи, не переходя в другие разделы, что колоссально экономит время и повышает эффективность.

---

### **Часть 1 из 5: Публичная часть платформы — Главная страница и привлечение внимания**

**Общая философия:** Создать яркую, динамичную и вызывающую доверие "витрину", которая быстро и убедительно доносит до гостя ключевые преимущества платформы. Посетитель должен за 30 секунд понять: "Это то, что я искал для своих тренировок". Интерфейс должен быть безупречным на всех устройствах, с акцентом на мобильные.

---

#### **Модуль 1: Главная страница (Landing Page)**

**Цель модуля:** Захватить внимание посетителя с первого экрана, четко сформулировать уникальное торговое предложение (УТП) и направить его к целевому действию — регистрации или дальнейшему изучению платформы.

**Топ-5 ключевых нюансов для разработки:**

*   **Нюанс №1: "Геройский" первый экран с четким УТП и двойным CTA.**
    *   **Проблема:** Посетитель попадает на сайт и видит абстрактную картинку и размытый текст. Он не понимает, чем этот сервис лучше десятков других, и уходит через 5 секунд.
    *   **Детальное решение (React/TS + Tailwind CSS):**
        1.  **Структура:** Создается компонент `HeroSection.tsx`. Он занимает всю высоту первого экрана (`h-screen`). На фон помещается качественное, динамичное, но не перегруженное видео или изображение (например, короткий ролик с нарезкой моментов тренировок, достижений, взаимодействия тренера и клиента). Видео должно быть оптимизировано для веба (`.webm`, `.mp4`) и иметь `poster` изображение для быстрой загрузки.
        2.  **УТП:** Поверх фона, с помощью `z-index` и `position: absolute`, накладывается текстовый блок, выровненный по центру. Главный заголовок (`<h1 className="text-4xl md:text-6xl font-extrabold ...">`) должен быть коротким и бить в главную "боль" клиента: **"Достигай своих фитнес-целей с персональным тренером. Онлайн. Эффективно."**. Под ним — краткий подзаголовок, раскрывающий суть: "Индивидуальные программы, отслеживание прогресса и поддержка от лучших специалистов на единой платформе".
        3.  **Двойной Call-to-Action (CTA):** Под текстом располагаются две кнопки:
            *   **Основная:** Яркая, контрастная, с главным целевым действием: `<Link to="/signup" className="... bg-blue-600 hover:bg-blue-700 ...">Начать бесплатно</Link>` (или "Найти тренера").
            *   **Второстепенная:** Менее заметная ("ghost" стиль), для тех, кто не готов к действию, но хочет узнать больше: `<button onClick={scrollToFeatures} className="... border border-white text-white ...">Узнать больше</button>`. `scrollToFeatures` — это JS-функция, которая плавно прокручивает страницу к следующему блоку.
    *   **Важность для MVP:** Первый экран — самая важная часть лендинга. Он должен мгновенно ответить на вопрос посетителя "Что это и зачем мне это нужно?". Двойной CTA позволяет работать с двумя сегментами аудитории: "горячей" и "теплой".

*   **Нюанс №2: Блок "Социальное доказательство" для создания доверия.**
    *   **Проблема:** Новый сервис, никто о нем не знает. Посетитель думает: "А это вообще работает? Кто-то этим пользуется?".
    *   **Детальное решение (React/TS + Tailwind CSS):**
        1.  Сразу под первым экраном располагается компонент `SocialProof.tsx`. Это узкая полоса, которая может содержать:
        2.  **"Нам доверяют":** Логотипы известных фитнес-клубов, брендов спортивного питания или медиа, если есть партнерства (даже если их нет в MVP, блок нужно спроектировать).
        3.  **Отзывы:** Небольшие карточки с отзывами (фейковыми для старта, но реалистичными). Каждая карточка (`<div className="bg-white p-6 rounded-lg shadow-md">...</div>`) содержит: аватар клиента, имя, и короткую цитату ("Сбросила 5 кг за месяц, тренер всегда на связи!"). Можно сделать этот блок в виде автоматического слайдера/карусели (используя библиотеку `Swiper.js` или `Embla Carousel`).
        4.  **Цифры:** Крупные, анимированные цифры, которые "прокручиваются" до нужного значения при попадании в область видимости (с помощью `Intersection Observer API` и библиотеки типа `react-countup`). Например: "**10+** Тренеров-экспертов", "**200+** Успешных трансформаций", "**15+** Активных челленджей". На старте цифры могут быть скромными, но честными.
    *   **Важность для MVP:** Это один из самых сильных психологических триггеров. Посетители видят, что другие люди уже пользуются сервисом и довольны им, что резко снижает барьер недоверия.

*   **Нюанс №3: Наглядная демонстрация "Как это работает".**
    *   **Проблема:** Посетитель не понимает, как именно будет происходить взаимодействие. Текст сложен для восприятия.
    *   **Детальное решение (React/TS + Tailwind CSS):**
        1.  Создается компонент `HowItWorks.tsx`. Он должен быть максимально визуальным.
        2.  **Пошаговая инструкция:** Используется Grid- или Flexbox-верстка для создания 3-4 шагов. Каждый шаг (`<div className="flex flex-col items-center">...</div>`) состоит из:
            *   Крупной, красивой иконки или иллюстрации, отражающей суть шага.
            *   Заголовка ("Шаг 1: Выберите своего тренера").
            *   Краткого описания ("Ознакомьтесь с профилями, рейтингами и отзывами, чтобы найти идеального наставника").
        3.  **Визуальная связь:** Шаги можно соединить пунктирной линией (сделанной с помощью SVG или CSS), чтобы показать последовательность.
        4.  **Интерактивный элемент (опционально, но эффектно):** Можно сделать переключатель "Для клиента" / "Для тренера", который будет менять текст и иконки в этих шагах, показывая преимущества для обеих сторон.
    *   **Важность для MVP:** Упрощает сложное. Превращает абстрактное описание сервиса в простую и понятную инструкцию, снимая у посетителя страх "а вдруг я не разберусь".

*   **Нюанс №4: Демонстрация ключевых "фич" через визуал.**
    *   **Проблема:** Простое перечисление функций ("персональные программы, чат, челленджи") — скучно и неубедительно.
    *   **Детальное решение (React/TS + Tailwind CSS):**
        1.  Создается серия блоков в компоненте `Features.tsx`. Используется чередующаяся верстка: "картинка слева, текст справа", затем "текст слева, картинка справа".
        2.  **Визуал:** Вместо абстрактных картинок, используются реальные (или качественно сделанные) скриншоты интерфейса приложения. Например, для фичи "Интерактивные тренировки" показывается скриншот "режима выполнения" на телефоне. Для "Челленджей" — скриншот ленты с отчетами. Картинки можно поместить в стилизованную рамку браузера или телефона для реалистичности.
        3.  **Анимация:** При прокрутке, когда блок попадает в зону видимости, текстовый блок и картинка могут плавно "выезжать" навстречу друг другу с помощью `Intersection Observer API` и CSS-трансформаций/переходов Tailwind.
    *   **Важность для MVP:** Посетитель должен не прочитать, а **увидеть** продукт. Скриншоты интерфейса — это самое честное и убедительное доказательство того, что ваш продукт реален, продуман и удобен.

*   **Нюанс №5: "Липкий" Header и постоянный призыв к действию.**
    *   **Проблема:** Посетитель прокрутил лендинг до конца, заинтересовался, но кнопка регистрации осталась где-то наверху. Он может просто закрыть вкладку из-за лени.
    *   **Детальное решение (React/TS + Tailwind CSS):**
        1.  Компонент `Header.tsx` должен иметь класс `sticky top-0 z-50` и менять свой фон с прозрачного на белый при прокрутке (это легко делается с помощью `useEffect` и отслеживания `window.scrollY`).
        2.  В `Header` всегда должны быть видны ключевые ссылки ("Тренеры", "Челленджи") и, самое главное, кнопка **"Регистрация"**, стилизованная как основная CTA-кнопка.
        3.  В самом конце лендинга, перед футером, должен располагаться большой, заметный блок `FinalCTA.tsx` с мощным заголовком ("Готовы изменить свое тело и жизнь?") и самой большой на странице кнопкой "Начать бесплатно".
    *   **Важность для MVP:** Целевое действие должно быть доступно пользователю в любой момент, в любой точке страницы. Нельзя заставлять его искать кнопку регистрации.

---

### **Часть 2 из 5: Публичная часть платформы — Список тренеров и система рейтинга**

**Общая философия:** Создать прозрачную и вызывающую доверие систему выбора тренера, похожую на лучшие маркетплейсы (например, Airbnb или Upwork). Посетитель должен чувствовать, что у него есть вся необходимая информация для принятия взвешенного решения, и что платформа предоставляет честные, объективные данные.

---

#### **Модуль 2: Страница "Тренеры" (Каталог)**

**Цель модуля:** Предоставить посетителю удобный, фильтруемый каталог всех тренеров на платформе, позволяющий быстро найти подходящего специалиста по ключевым параметрам.

**Топ-5 ключевых нюансов для разработки:**

*   **Нюанс №1: Карточка тренера с "быстрой" информацией.**
    *   **Проблема:** Список тренеров — это просто сетка из фотографий и имен. Чтобы узнать что-то о тренере, нужно переходить на его страницу, а потом возвращаться назад. Это утомительно и неэффективно.
    *   **Детальное решение (React/TS + Supabase + Tailwind CSS):**
        1.  **Бэкенд:** Запрос на `/api/v1/coaches/public` должен возвращать обогащенный список тренеров. Для каждого тренера, с помощью SQL-функции в Supabase, нужно агрегировать и посчитать:
            *   Средний рейтинг (`avg_rating`).
            *   Количество отзывов (`reviews_count`).
            *   Количество активных клиентов (`active_clients_count`).
        2.  **Фронтенд:** Компонент `CoachCard.tsx` будет сверстан на Tailwind с использованием `flexbox` и `grid`. Карточка должна содержать:
            *   **Фото:** Качественное фото-аватар.
            *   **Имя и специализация:** "Иван Иванов, *Снижение веса, Набор массы*". Специализации — это теги.
            *   **Рейтинг:** Компонент `StarRating.tsx` (звездочки), который отрисовывает рейтинг (например, 4.8) и рядом в скобках количество отзывов.
            *   **Ключевые метрики:** Небольшие иконки с подписями: "Клиентов сейчас: **15**", "На платформе: **6 мес.**".
            *   **Цена:** "От **3000 ₽** / месяц".
        3.  Вся карточка должна быть обернута в `<Link to={\`/coaches/\${coach.slug}\`}>...</Link>`, а при наведении на нее должен применяться эффект (например, легкое увеличение `scale-105` и тень `shadow-xl`), стилизованный через `transition` в Tailwind.
    *   **Важность для MVP:** Позволяет посетителю быстро сканировать список и сравнивать тренеров по ключевым параметрам, не совершая лишних кликов. Это значительно улучшает пользовательский опыт на главной странице выбора.

*   **Нюанс №2: "Умная" фильтрация и сортировка.**
    *   **Проблема:** Тренеров становится больше 10-15. Посетителю, который ищет специалиста по йоге, приходится просматривать профили пауэрлифтеров. Он тратит время и уходит.
    *   **Детальное решение (React/TS + TanStack Query + Tailwind CSS):**
        1.  **UI:** Сбоку (на десктопе) или в выезжающей панели (на мобильных) располагается компонент `FiltersPanel.tsx`. Он содержит:
            *   **Фильтр по специализации:** Список чекбоксов (`Йога`, `Пауэрлифтинг`, `Реабилитация` и т.д.).
            *   **Фильтр по цене:** Слайдер-диапазон (можно использовать headless-библиотеку `nouislider` или аналоги и стилизовать ее с Tailwind).
            *   **Фильтр по рейтингу:** Чекбоксы "4.5+" , "4.0+" и т.д.
        2.  **Сортировка:** Над списком тренеров — выпадающий список (`<select>`), стилизованный с Tailwind, с опциями: "По популярности (умолчание)", "Сначала с высоким рейтингом", "Сначала дешевле", "Сначала дороже".
        3.  **Логика:** Состояние всех фильтров и сортировки хранится в одном объекте `useState`. `TanStack Query` используется для запроса данных. Ключ запроса будет включать сериализованный объект фильтров: `queryKey: ['coaches', filters]`. При изменении любого фильтра, `TanStack Query` автоматически сделает новый запрос на бэкенд с параметрами (`/api/v1/coaches/public?specialization=yoga&price_lte=5000...`). Это обеспечивает кэширование и бесшовное обновление списка.
    *   **Важность для MVP:** Превращает простой каталог в мощный инструмент подбора. Позволяет каждому посетителю быстро найти релевантного специалиста, что напрямую влияет на конверсию в регистрацию.

*   **Нюанс №3: Объективная и прозрачная система рейтинга.**
    *   **Проблема:** Посетитель видит рейтинг "5.0", но не доверяет ему, так как не понимает, откуда он взялся. "Наверняка накрутили".
    *   **Детальное решение (Node.js + Supabase + React/TS):**
        1.  **Бэкенд:** Отзыв и рейтинг может оставить **только** клиент, который был привязан к тренеру и занимался с ним не менее N дней (например, 14). Эта логика проверяется на сервере перед сохранением отзыва. Это предотвращает накрутки.
        2.  **UI Профиля тренера:** На странице тренера, в разделе "Отзывы", у каждого отзыва должна быть пометка "Проверенный клиент" или "Занимался 3 месяца".
        3.  **Расчет рейтинга:** Средний рейтинг должен считаться на стороне базы данных как агрегированное значение. Это не просто среднее арифметическое. Можно использовать более сложные формулы (например, Байесовский средний), которые учитывают количество отзывов, чтобы тренер с одним отзывом "5.0" не был выше тренера с 50 отзывами и рейтингом "4.9".
        4.  **Визуализация:** В профиле тренера должна быть детальная разбивка рейтинга: гистограмма, показывающая, сколько было оценок "5", "4", "3" и т.д.
    *   **Важность для MVP:** Создает доверие к платформе. Посетители видят, что система честная и объективная, и начинают больше доверять информации, представленной на сайте.

*   **Нюанс №4: "Пустое состояние" для фильтров.**
    *   **Проблема:** Посетитель выбрал фильтры "Йога", "цена до 1000 ₽", "рейтинг 5.0" и получил пустой список. Он думает, что сайт сломался.
    *   **Детальное решение (React/TS + Tailwind CSS):**
        1.  Когда `useQuery` возвращает `isSuccess` и `data` является пустым массивом, компонент `CoachesList.tsx` должен отрисовать не пустоту, а специальный компонент `NoResults.tsx`.
        2.  Этот компонент будет содержать:
            *   Иконку (например, грустный смайлик или лупа).
            *   Заголовок: "Тренеры не найдены".
            *   Поясняющий текст: "Попробуйте изменить или сбросить фильтры, чтобы увидеть больше специалистов".
            *   Большую, заметную кнопку **"Сбросить все фильтры"**, которая очищает объект состояния фильтров, что приводит к новому запросу и показу всех тренеров.
    *   **Важность для MVP:** Управляет негативным сценарием. Вместо того, чтобы оставить пользователя в тупике, интерфейс помогает ему исправить ситуацию и продолжить поиск.

*   **Нюанс №5: Оптимизация для SEO и прямые ссылки.**
    *   **Проблема:** Страница тренеров — это SPA (Single Page Application), и поисковики могут плохо ее индексировать. Также невозможно поделиться ссылкой на отфильтрованный список.
    *   **Детальное решение (React/TS + React Router):**
        1.  **Рендеринг на стороне сервера (SSR):** Для публичных страниц ("Главная", "Тренеры", "Профиль тренера") в идеале нужно использовать фреймворк поверх React, такой как **Next.js** или **Remix**. Если для MVP это слишком сложно, то нужно использовать как минимум `react-helmet-async` для управления мета-тегами (`<title>`, `<meta name="description">`) на клиенте.
        2.  **Синхронизация фильтров с URL:** Состояние фильтров должно храниться не только в React `useState`, но и синхронизироваться с URL-параметрами. Для этого используется хук `useSearchParams` из `react-router-dom`. Когда пользователь меняет фильтр, хук обновляет URL (`/coaches?specialization=yoga`). Когда пользователь заходит по такой ссылке, состояние фильтров инициализируется из URL.
    *   **Важность для MVP:** Позволяет пользователям делиться ссылками на конкретные подборки тренеров ("смотри, я нашел нам тренеров по йоге!"). А правильное управление мета-тегами — это первый и самый важный шаг для того, чтобы ваш сервис начали находить в поисковых системах.

---

### **Часть 3 из 5: Публичная часть платформы — Профиль тренера**

**Общая философия:** Создать исчерпывающую и убедительную "продающую" страницу для каждого тренера. Посетитель должен не просто прочитать сухие факты, а почувствовать личность тренера, его подход, увидеть результаты его работы и окончательно убедиться, что именно этот специалист поможет ему достичь цели.

---

#### **Модуль 3: Страница "Профиль тренера"**

**Цель модуля:** Предоставить посетителю всю необходимую информацию для принятия решения о сотрудничестве с конкретным тренером, включая его философию, достижения, отзывы клиентов и четкое описание услуг.

**Топ-5 ключевых нюансов для разработки:**

*   **Нюанс №1: Структура профиля с "липкой" CTA-колонкой.**
    *   **Проблема:** Посетитель читает длинное описание тренера, его философию, смотрит сертификаты. Когда он наконец принимает решение, ему нужно скроллить обратно наверх, чтобы найти кнопку "Начать тренировки".
    *   **Детальное решение (React/TS + Tailwind CSS):**
        1.  **Структура:** Страница профиля (`CoachProfilePage.tsx`) на десктопе должна быть разделена на две колонки с помощью CSS Grid (`<div className="grid grid-cols-1 md:grid-cols-3 gap-8">...</div>`).
            *   **Основная колонка (2/3 ширины):** Здесь располагается весь контент — "Обо мне", "Сертификаты", "Результаты клиентов", "Отзывы".
            *   **Боковая колонка (1/3 ширины):** Эта колонка должна быть "липкой" (`sticky top-24`).
        2.  **Содержимое "липкой" колонки:** В ней находится самая важная информация для принятия решения:
            *   Крупный аватар тренера.
            *   Имя и краткий статус ("Мастер спорта по тяжелой атлетике").
            *   Блок с рейтингом и количеством отзывов.
            *   Краткий перечень ключевых метрик ("Клиентов на платформе: 15", "Провел тренировок: 500+").
            *   Самое главное — большая, заметная кнопка **"Начать тренировки с [Имя тренера]"**. Эта кнопка ведет на страницу регистрации, но с параметром в URL (`/signup?coach_id=...`), чтобы после регистрации клиент был автоматически привязан к этому тренеру.
    *   **Важность для MVP:** Кнопка целевого действия всегда находится перед глазами пользователя, вне зависимости от того, какую часть профиля он изучает. Это значительно повышает конверсию.

*   **Нюанс №2: Блок "Результаты клиентов" (до/после).**
    *   **Проблема:** Текст о профессионализме тренера — это хорошо, но ничто не убеждает лучше, чем реальные результаты.
    *   **Детальное решение (React/TS + Supabase Storage + Tailwind CSS):**
        1.  **Бэкенд:** В кабинете тренера должен быть раздел, где он может загружать кейсы своих клиентов: две фотографии ("до" и "после"), имя клиента (с его согласия), и краткую историю успеха ("Мария, -15 кг за 4 месяца. Нормализовали питание и добавили 3 силовые тренировки в неделю."). Фотографии загружаются в Supabase Storage.
        2.  **UI:** На публичной странице тренера создается компонент `ClientResults.tsx`. Он отображает эти кейсы в виде сетки карточек.
        3.  Каждая карточка (`<div className="bg-gray-50 rounded-lg overflow-hidden">...</div>`) содержит:
            *   Компонент-слайдер для сравнения фото "до/после" (можно использовать готовую React-библиотеку, например, `react-compare-slider`, и стилизовать ее).
            *   Имя клиента и его историю.
        4.  Этот блок должен быть одним из первых в профиле, так как он обладает огромной убедительной силой.
    *   **Важность для MVP:** Это самое мощное социальное доказательство. Оно визуализирует результат, который может получить потенциальный клиент, и напрямую отвечает на его вопрос "А мне это поможет?".

*   **Нюанс №3: Подробные и фильтруемые отзывы.**
    *   **Проблема:** Все отзывы свалены в одну кучу. Посетителю, который хочет набрать массу, не интересны отзывы о похудении.
    *   **Детальное решение (React/TS + Supabase + Tailwind CSS):**
        1.  **Бэкенд:** Когда клиент оставляет отзыв, он может (необязательно) выбрать тег, соответствующий его цели (например, "Похудение", "Набор массы", "Реабилитация"). Эти теги берутся из специализаций тренера.
        2.  **UI:** В разделе "Отзывы" (`ReviewsSection.tsx`) над списком отзывов располагаются кнопки-фильтры, стилизованные как "пилюли" (`<button className="px-3 py-1 text-sm rounded-full ...">...</button>`). "Все отзывы", "Похудение (5)", "Набор массы (8)".
        3.  При клике на фильтр, список отзывов на клиенте (без перезагрузки страницы) фильтруется, показывая только релевантные. Состояние фильтра управляется через `useState`.
        4.  Каждый отзыв (`ReviewCard.tsx`) должен содержать аватар клиента, имя, оценку (звездочки), текст отзыва и дату.
    *   **Важность для MVP:** Позволяет посетителям найти отзывы от людей с похожими целями, что делает их гораздо более убедительными и персонализированными.

*   **Нюанс №4: "Философия тренера" и медиа-контент.**
    *   **Проблема:** Профиль тренера — сухой и безличный, как резюме. Непонятно, какой он человек и какой у него подход.
    *   **Детальное решение (React/TS + Tailwind CSS):**
        1.  **Блок "Обо мне / Мой подход":** Это должен быть не просто текст. Используется плагин `@tailwindcss/typography` для красивого форматирования большого текстового блока, который тренер пишет в своем кабинете. Текст должен быть разбит на абзацы, с подзаголовками.
        2.  **Видео-визитка:** Предусмотреть возможность для тренера вставить ссылку на видео с YouTube или Vimeo. На странице профиля это видео будет встроено в красивый плеер. Видео, где тренер лично рассказывает о себе и своем подходе, — невероятно мощный инструмент для создания доверия.
        3.  **Галерея сертификатов:** Не просто список, а галерея изображений, которые можно открыть и рассмотреть в полном размере (используя lightbox-библиотеку, например, `yet-another-react-lightbox`, которую легко стилизовать).
    *   **Важность для MVP:** Позволяет тренеру раскрыть свою личность и экспертность. Клиенты выбирают не только программу, но и человека, с которым им предстоит работать. Этот блок помогает установить эмоциональную связь.

*   **Нюанс №5: Четкое описание услуг и тарифов.**
    *   **Проблема:** Непонятно, что именно входит в стоимость и какие есть варианты сотрудничества. Посетитель боится "кота в мешке".
    *   **Детальное решение (React/TS + Tailwind CSS):**
        1.  Создается компонент `ServicesSection.tsx`. В нем — несколько карточек тарифов (например, "Онлайн-ведение", "Разовая консультация").
        2.  Каждая карточка тарифа (`<div className="border rounded-lg p-6">...</div>`) должна четко и по пунктам (с иконками-галочками) перечислять, что в нее входит:
            *   `✓` Составление индивидуальной программы тренировок
            *   `✓` Еженедельная коррекция плана
            *   `✓` Чат с тренером 24/7
            *   `✗` Персональные онлайн-тренировки
        3.  Цена должна быть указана крупно и понятно. Одна из карточек может быть выделена (например, с помощью цветной рамки и плашки "Самый популярный"), чтобы подтолкнуть пользователя к выбору.
        4.  Под тарифами — блок FAQ ("Часто задаваемые вопросы"), где даны ответы на типичные вопросы: "Как происходит первая тренировка?", "Что делать, если я уезжаю в отпуск?", "Как происходит оплата?".
    *   **Важность для MVP:** Снимает последние возражения и вопросы. Посетитель точно понимает, за что он платит, и что он получит, что делает решение о регистрации простым и прозрачным.

---

### **Часть 4 из 5: Публичная часть платформы — Витрина Челленджей и Достижений**

**Общая философия:** Показать, что платформа — это не просто инструмент, а живое, активное сообщество. Гость должен увидеть энергию, соревновательный дух и реальные достижения участников, что вызовет у него желание стать частью этого движения.

---

#### **Модуль 4: Страница "Челленджи"**

**Цель модуля:** Продемонстрировать гостю самые интересные и популярные публичные челленджи, показать активность внутри них и использовать это как мощный инструмент для конвертации в регистрацию.

**Топ-5 ключевых нюансов для разработки:**

*   **Нюанс №1: Разделение на "Активные" и "Прошедшие" челленджи.**
    *   **Проблема:** Гость заходит на страницу и видит 2-3 активных челленджа. Ему может показаться, что на платформе мало активности.
    *   **Детальное решение (React/TS + Supabase + Tailwind CSS):**
        1.  **UI:** Страница `PublicChallengesPage.tsx` должна иметь две вкладки-таба (аналогично как в кабинете тренера): **"Идут сейчас"** и **"Архив достижений"**.
        2.  **Бэкенд:** Эндпоинт `/api/v1/challenges/public` должен принимать параметр `status` (`?status=active` или `?status=completed`).
        3.  **"Идут сейчас":** Этот раздел показывает все "Открытые" челленджи, которые активны в данный момент. Цель — показать, к чему можно присоединиться прямо сейчас.
        4.  **"Архив достижений":** Этот раздел показывает самые успешные и интересные завершенные челленджи. Это работает как социальное доказательство и демонстрирует историю платформы. У карточки завершенного челленджа можно показать итоговую статистику: "Участников: 50", "Всего выполнено заданий: 1250".
    *   **Важность для MVP:** Создает ощущение масштаба и истории. Посетитель видит, что челленджи — это не разовая акция, а постоянная, регулярная часть жизни на платформе.

*   **Нюанс №2: Интерактивная карточка "живого" челленджа.**
    *   **Проблема:** Карточка челленджа показывает только название и даты. Она "мертвая" и не передает динамики.
    *   **Детальное решение (React/TS + Supabase + Tailwind CSS):**
        1.  **Бэкенд:** Запрос на получение активных челленджей должен быть обогащенным. Для каждого челленджа нужно получить:
            *   Количество участников (`participants_count`).
            *   **Последние 3-5 отчетов** (ссылки на фото, если отчеты с фото).
        2.  **UI:** Компонент `ChallengeCard.tsx` на публичной странице будет более сложным, чем в каталоге тренеров. Он будет содержать:
            *   Название и краткое описание.
            *   Прогресс-бар, показывающий, сколько дней прошло / осталось (`<div className="w-full bg-gray-200 rounded-full h-2.5"><div className="bg-blue-600 h-2.5 rounded-full" style={{ width: '75%' }}></div></div>`).
            *   Счетчик участников ("Участвуют: **25** человек").
            *   **Мини-лента активности:** Небольшой блок, где в виде маленьких аватарок или мини-превью фотографий динамически (можно даже с анимацией появления) отображаются последние отчеты участников. Это создает ощущение, что "прямо сейчас там что-то происходит".
    *   **Важность для MVP:** Превращает карточку из статичного описания в окно, через которое можно подсмотреть за реальной жизнью внутри платформы. Это вызывает любопытство и желание присоединиться.

*   **Нюанс №3: "Заглушка" для просмотра с призывом к действию.**
    *   **Проблема:** Гость кликает на интересный челлендж, чтобы посмотреть подробности, но ему сразу показывают форму регистрации. Это агрессивно и может отпугнуть.
    *   **Детальное решение (React/TS + Tailwind CSS):**
        1.  Для каждого публичного челленджа создается своя детальная страница (`PublicChallengeDetailPage.tsx`).
        2.  На этой странице гость может видеть **ограниченную** информацию:
            *   Полное описание, правила и цель челленджа.
            *   Список участников (только аватарки и имена, без ссылок на профили).
            *   **Лента активности:** Гость видит ленту с отчетами (фотографии, текстовые отчеты), **но она размыта** (`filter: blur(8px)` в Tailwind) или поверх нее наложен полупрозрачный оверлей.
        3.  Поверх "размытой" ленты расположен большой, но не агрессивный блок:
            *   Заголовок: "Присоединяйтесь, чтобы увидеть все детали и принять участие!".
            *   Текст: "Зарегистрируйтесь бесплатно, чтобы получить доступ к полной ленте активности, общаться с участниками и начать свой путь к цели".
            *   Большая кнопка **"Зарегистрироваться и присоединиться"**.
    *   **Важность для MVP:** Это классический маркетинговый прием "показать ценность, но ограничить доступ". Гость видит, что внутри есть интересный контент, и регистрация становится для него логичным шагом для получения полного доступа.

*   **Нюанс №4: Демонстрация достижений и наград.**
    *   **Проблема:** Непонятно, что получают победители или даже просто участники. Мотивация для участия неясна.
    *   **Детальное решение (React/TS + Supabase + Tailwind CSS):**
        1.  **Бэкенд:** При создании челленджа, тренер (в будущих версиях) сможет указывать призы или награды. В MVP можно сделать проще: у каждого челленджа в таблице `challenges` есть поле `achievements_description` (текстовое).
        2.  **UI:** На детальной странице челленджа (и на карточке в списке) есть специальный блок "Что вы получите?". В нем с иконками перечисляются бенефиты:
            *   `✓` Поддержка тренера и единомышленников
            *   `✓` Гарантированное формирование привычки
            *   🏆 **Награда:** (здесь выводится текст из `achievements_description`, например: "Победитель получит скидку 50% на следующий месяц ведения").
        3.  **Виртуальные ачивки:** Можно спроектировать систему виртуальных значков (бейджей). В Supabase создается таблица `badges`. На странице завершенного челленджа можно показывать блок "Герои челленджа" с аватарами победителей и иконкой полученного ими уникального бейджа ("Легенда планки", "Магистр чистой еды").
    *   **Важность для MVP:** Четко отвечает на вопрос "Что мне это даст?". Материальные или виртуальные награды являются сильным мотиватором и показывают, что платформа ценит усилия своих пользователей.

*   **Нюанс №5: SEO-оптимизация для каждой страницы челленджа.**
    *   **Проблема:** Челленджи — это уникальный и интересный контент, который люди могут искать в Google ("челлендж 30 дней планка онлайн"). Если эти страницы не индексируются, вы теряете бесплатный органический трафик.
    *   **Детальное решение (React/TS + React Router/Next.js):**
        1.  **Человекопонятные URL (slugs):** У каждого челленджа должен быть `slug` (например, `30-day-plank-challenge`), который используется в URL: `/challenges/30-day-plank-challenge`.
        2.  **Мета-теги:** Как и для профилей тренеров, критически важно управлять мета-тегами на каждой странице. С помощью `react-helmet-async` (или встроенных средств Next.js) для каждой страницы челленджа генерируются уникальные:
            *   `<title>`: "Челлендж '30 дней планки' — Прими вызов на нашей платформе!".
            *   `<meta name="description">`: "Участвуй в онлайн-челлендже по планке вместе с десятками других атлетов. Поддержка тренера, отслеживание прогресса и мотивация. Присоединяйся сегодня!".
        3.  **Структурированные данные (Schema.org):** Для продвинутого SEO можно добавить JSON-LD разметку для события (`Event`), что поможет поисковикам лучше понять содержимое страницы.
    *   **Важность для MVP:** Закладывает фундамент для будущего органического роста. Хорошо оптимизированные страницы челленджей могут стать основным источником новых, целевых пользователей для платформы.

---

### **Часть 5 из 5: Публичная часть платформы — Футер, Навигация и общие элементы**

**Общая философия:** Обеспечить целостность и удобство навигации по всему публичному сайту. Каждый элемент, от шапки до подвала, должен работать на общую цель: укрепление доверия, предоставление информации и направление пользователя к регистрации.

---

#### **Модуль 5: Сквозные элементы (Header, Footer) и общие страницы**

**Цель модуля:** Создать интуитивно понятную навигационную структуру и предоставить доступ к важной, но второстепенной информации (FAQ, контакты, юридические документы), что является признаком зрелого и надежного продукта.

**Топ-5 ключевых нюансов для разработки:**

*   **Нюанс №1: "Умный" и адаптивный Header.**
    *   **Проблема:** Шапка сайта перегружена ссылками или, наоборот, не содержит важных кнопок. На мобильных устройствах она занимает слишком много места или превращается в неудобное "бургер"-меню.
    *   **Детальное решение (React/TS + Tailwind CSS + Headless UI):**
        1.  **Компонент `Header.tsx`:** Он будет `sticky top-0 z-50` и менять свой фон с прозрачного (на главной странице) на `bg-white/80 backdrop-blur-sm` (на остальных страницах или при скролле) для эффекта "матового стекла".
        2.  **Десктопная версия:** Слева — логотип. По центру — ключевые пункты меню: "Тренеры", "Челленджи", "Как это работает". Справа — две кнопки: "Войти" (для существующих пользователей, стиль "ghost") и **"Регистрация"** (основная CTA-кнопка).
        3.  **Мобильная версия:** При ширине экрана меньше `md` (медиа-запрос Tailwind), центральное меню скрывается. Появляется иконка "бургер". Для реализации доступного и анимированного мобильного меню используется библиотека `Headless UI` (`Transition` и `Menu` компоненты), которая идеально интегрируется с Tailwind. При открытии, меню выезжает сбоку и занимает весь экран, предоставляя доступ ко всем ссылкам. Кнопки "Войти" и "Регистрация" остаются видимыми в шапке даже в мобильной версии.
    *   **Важность для MVP:** Обеспечивает предсказуемую и удобную навигацию на любом устройстве. Постоянное присутствие кнопок "Войти" и "Регистрация" держит целевые действия в фокусе.

*   **Нюанс №2: Информационно-насыщенный и полезный Футер (Footer).**
    *   **Проблема:** Футер часто игнорируют, делая его свалкой неструктурированных ссылок. Это упущенная возможность для навигации и укрепления доверия.
    *   **Детальное решение (React/TS + Tailwind CSS):**
        1.  Компонент `Footer.tsx` должен быть сверстан с помощью CSS Grid на несколько колонок (`grid-cols-2 md:grid-cols-4`).
        2.  **Колонка 1: "Платформа"**. Основные навигационные ссылки: "Тренеры", "Челленджи", "О нас", "Блог" (даже если блога еще нет, ссылку можно предусмотреть).
        3.  **Колонка 2: "Поддержка"**. Важные ссылки для пользователя: "FAQ (Частые вопросы)", "Связаться с нами".
        4.  **Колонка 3: "Юридическая информация"**. Обязательные ссылки: "Условия использования", "Политика конфиденциальности".
        5.  **Колонка 4: Социальные сети и CTA.** Иконки социальных сетей (Instagram, YouTube и т.д.) и, возможно, небольшая форма подписки на рассылку новостей (даже если она пока не работает, сбор email'ов — это ценный актив).
        6.  В самом низу, под колонками — копирайт: `© {new Date().getFullYear()} [Название Платформы]. Все права защищены.`.
    *   **Важность для MVP:** Футер — это "карта сайта" и знак надежности. Наличие ссылок на юридические документы и поддержку показывает, что это серьезный проект, а не сайт-однодневка.

*   **Нюанс №3: Страница FAQ, которая реально помогает.**
    *   **Проблема:** Страница FAQ — это сплошная стена текста, которую никто не читает.
    *   **Детальное решение (React/TS + Tailwind CSS + Headless UI):**
        1.  Создается страница `FAQPage.tsx`. Вопросы должны быть сгруппированы по категориям: "Для клиентов", "Для тренеров", "Оплата и подписки".
        2.  Каждый вопрос-ответ реализуется через интерактивный компонент-"аккордеон". Для этого идеально подходит компонент `Disclosure` из `Headless UI`, который управляет состоянием "открыто/закрыто" и доступностью (ARIA-атрибуты).
        3.  При клике на вопрос (`<Disclosure.Button>`), ответ (`<Disclosure.Panel>`) плавно появляется с анимацией. Справа от вопроса — иконка-шеврон, которая анимированно поворачивается при открытии/закрытии.
        4.  Вверху страницы — поле поиска, которое в реальном времени будет фильтровать вопросы и ответы на странице, подсвечивая совпадения.
    *   **Важность для MVP:** Снимает нагрузку с будущей поддержки. Позволяет пользователям самостоятельно находить ответы на свои вопросы, что улучшает их опыт и снижает их тревожность перед регистрацией.

*   **Нюанс №4: Бесшовный переход от публичной части к приложению.**
    *   **Проблема:** Публичный сайт и само веб-приложение (кабинеты) выглядят и ощущаются по-разному. Разные шрифты, цвета, стили. Это создает ощущение "сшитого из кусков" продукта.
    *   **Детальное решение (Vite + Tailwind CSS):**
        1.  **Единая конфигурация Tailwind:** Проект должен иметь единый файл `tailwind.config.js`, где определены общие цвета, шрифты, размеры отступов и т.д. (`theme`). Этот конфиг используется как для публичных страниц, так и для внутренних кабинетов.
        2.  **Общие компоненты:** Создается папка `src/components/common` (или `shared`), где лежат компоненты, используемые и там, и там: `Button.tsx`, `Input.tsx`, `Modal.tsx`, `Avatar.tsx`. Они стилизованы с помощью Tailwind и принимают `props` для вариаций.
        3.  **Единая точка входа для стилей:** В `main.tsx` импортируется один главный CSS-файл (`index.css`), где лежат базовые стили и директивы Tailwind.
    *   **Важность для MVP:** Создает целостный и брендированный пользовательский опыт. Клиент не чувствует резкого перехода, когда логинится в систему, что повышает общее восприятие качества продукта.

*   **Нюанс №5: Оптимизация производительности и Lighthouse.**
    *   **Проблема:** Публичный сайт медленно грузится, особенно на мобильных устройствах, из-за тяжелых картинок, видео и неоптимизированного кода. Посетитель уходит, не дождавшись загрузки.
    *   **Детальное решение (React/TS + Vite):**
        1.  **Оптимизация изображений:** Все растровые изображения (JPEG, PNG) на лендинге должны быть пропущены через инструменты сжатия (например, `tinypng.com`) и по возможности использовать современные форматы, такие как `.webp`. Vite может помочь с автоматизацией этого процесса через плагины.
        2.  **Ленивая загрузка (Lazy Loading):** Изображения и компоненты, которые находятся "ниже первого экрана", не должны загружаться сразу. Для изображений используется атрибут `loading="lazy"`. Для React-компонентов — `React.lazy()` и `<Suspense>`.
        3.  **Code Splitting:** Vite делает это автоматически на уровне роутов. Каждый публичный роут (`/`, `/coaches`, `/challenges`) будет загружаться как отдельный чанк JavaScript, а не одним большим файлом.
        4.  **Аудит Lighthouse:** Перед запуском MVP необходимо прогнать публичные страницы через инструмент Lighthouse в Chrome DevTools и стремиться к "зеленым" показателям (Performance, Accessibility, Best Practices, SEO > 90). Это гарантирует, что сайт быстрый, доступный и технически качественный.
    *   **Важность для MVP:** Скорость загрузки напрямую влияет на конверсию и SEO-ранжирование. Медленный сайт — это потерянные клиенты и деньги, особенно на мобильном трафике.


