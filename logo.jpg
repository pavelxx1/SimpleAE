(function() {
    function showNotificationUntilClick(message, type = 'info') {
        if (!document.body) return;

        const notification = document.createElement('div');
        // 1. Возвращаем текст в основной div
        notification.textContent = message.replace(/\\n/g, '\n');
        const uniqueId = 'notify-mask-' + Math.random().toString(16).slice(2);

        // --- Стили для основного блока уведомления ---
        const baseStyles = {
            position: 'fixed',
            bottom: '20px',
            left: '50%',
            transform: 'translateX(-50%)',
            minWidth: '180px',
            maxWidth: '90%',
            padding: '12px 20px',
            borderRadius: '15px',
            boxShadow: '0 3px 8px rgba(0, 0, 0, 0.25)',
            zIndex: '10001',
            fontFamily: 'Roboto, Arial, sans-serif', // Шрифт важен
            fontSize: '15px', // Размер важен
            lineHeight: '1.4', // Межстрочный интервал важен
            fontWeight: 'bold', // Жирность важна для маски
            textAlign: 'center', // Выравнивание текста
            whiteSpace: 'pre-wrap', // Учет переносов строк \n
            opacity: '0',
            transition: 'opacity 0.4s ease-in-out, bottom 0.4s ease-in-out',
            cursor: 'default',
            border: '1px solid black',
            // 2. Делаем текст прозрачным, чтобы он влиял на размер, но не был виден
            color: 'transparent',
            // --- Применение маски ---
            mask: `url(#${uniqueId})`,
            WebkitMask: `url(#${uniqueId})`
        };

        // --- Цвет фона ---
        let backgroundColor = '#2eaf17'; // Зеленый для info
        switch (type) {
            case 'success': backgroundColor = '#28a745'; break;
            case 'info':    backgroundColor = '#2eaf17'; break;
            case 'warning': backgroundColor = '#ffc107'; break;
            case 'error':   backgroundColor = '#dc3545'; break;
        }
        baseStyles.backgroundColor = backgroundColor;

        // Применяем стили к div
        Object.assign(notification.style, baseStyles);

        // --- Создание SVG и Маски ---
        // SVG и маска остаются почти такими же, но текст в SVG теперь
        // должен точно соответствовать тексту в div по расположению и стилю.
        const svgNS = "http://www.w3.org/2000/svg";
        const svg = document.createElementNS(svgNS, "svg");
        svg.style.position = 'absolute';
        svg.style.width = '0';
        svg.style.height = '0';
        svg.style.overflow = 'hidden';

        const defs = document.createElementNS(svgNS, "defs");
        const mask = document.createElementNS(svgNS, "mask");
        mask.setAttribute("id", uniqueId);
        // Используем objectBoundingBox, чтобы маска масштабировалась с элементом
        mask.setAttribute("maskUnits", "objectBoundingBox");
        mask.setAttribute("maskContentUnits", "objectBoundingBox");

        // 1. Белый прямоугольник (основа маски)
        const maskRect = document.createElementNS(svgNS, "rect");
        maskRect.setAttribute("x", "0");
        maskRect.setAttribute("y", "0");
        maskRect.setAttribute("width", "1");
        maskRect.setAttribute("height", "1");
        maskRect.setAttribute("fill", "white");
        mask.appendChild(maskRect);

        // 2. Черный текст (вырезает дырку)
        const maskText = document.createElementNS(svgNS, "text");
        maskText.setAttribute("x", "0.5"); // Центр по горизонтали
        maskText.setAttribute("y", "0.5"); // Примерный центр по вертикали (будет скорректирован tspan)
        maskText.setAttribute("fill", "black"); // Черный = вырезать
        maskText.setAttribute("text-anchor", "middle");
        maskText.setAttribute("dominant-baseline", "central"); // Базовая линия для вертикального центрирования
        maskText.setAttribute("font-family", baseStyles.fontFamily);
        maskText.setAttribute("font-weight", baseStyles.fontWeight);

        // --- ВАЖНО: Расчет относительного размера шрифта и межстрочного интервала ---
        // Эти значения должны соответствовать CSS стилям div!
        // fontSize: '15px', lineHeight: '1.4'
        // Рассчитать точные относительные значения сложно без знания высоты контейнера.
        // Используем приближенные значения, которые могут потребовать подстройки.
        // Попробуем связать размер шрифта SVG с CSS padding и line-height.
        // Это очень приблизительно!
        const approxCharHeightRatio = 0.08; // Примерное отношение высоты символа к высоте строки (зависит от шрифта)
        const approxLineHeightRatio = approxCharHeightRatio * parseFloat(baseStyles.lineHeight); // ~0.112
        const relativeFontSize = approxCharHeightRatio; // Используем отношение высоты символа

        maskText.setAttribute("font-size", relativeFontSize.toString()); // Относительный размер

        // Обработка переносов строк (\n) с помощью <tspan>
        const lines = message.replace(/\\n/g, '\n').split('\n');
        const totalLines = lines.length;
        // Начальная позиция Y для первой строки (корректируем под dominant-baseline="central")
        const startY = 0.5 - (totalLines - 1) * approxLineHeightRatio / 2;

        lines.forEach((line, index) => {
            const tspan = document.createElementNS(svgNS, "tspan");
            tspan.setAttribute("x", "0.5");
            // Устанавливаем абсолютную позицию Y для каждой строки
            tspan.setAttribute("y", (startY + index * approxLineHeightRatio).toString());
            tspan.textContent = line || ' ';
            maskText.appendChild(tspan);
        });

        mask.appendChild(maskText);
        defs.appendChild(mask);
        svg.appendChild(defs);
        document.body.appendChild(svg); // SVG все еще нужен

        // --- Логика скрытия уведомления (без изменений) ---
        let isDismissing = false;
        const dismissNotification = () => {
            if (isDismissing) return;
            isDismissing = true;
            document.removeEventListener('click', dismissNotification, { capture: true });
            document.removeEventListener('touchstart', dismissNotification, { capture: true });
            notification.style.opacity = '0';
            notification.style.bottom = '10px';
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
                if (svg.parentNode) {
                    svg.parentNode.removeChild(svg);
                }
            }, 400);
        };

        document.body.appendChild(notification);
        setTimeout(() => {
            notification.style.opacity = '1';
            notification.style.bottom = '30px';
            document.addEventListener('click', dismissNotification, { once: true, capture: true });
            document.addEventListener('touchstart', dismissNotification, { once: true, capture: true });
        }, 50);
    }

    // --- Остальной код AdBlocker (без изменений) ---
    let processedElements = new WeakSet();
    function scanForAds() { /* ... */ }
    function findAdContainer(element) { /* ... */ }
    function isAdContainer(element) { /* ... */ }
    setTimeout(() => {
        showNotificationUntilClick('AdBlocker v0.2\n@xrsrvd', 'info');
    }, 1000);
    setTimeout(scanForAds, 500);
    const observer = new MutationObserver(() => requestAnimationFrame(scanForAds));
    observer.observe(document.body, { childList: true, subtree: true });
    setInterval(scanForAds, 1000);

})();
