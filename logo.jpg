// Содержимое файла adblockscript.js (адаптировано для ясности, но функционально идентично предыдущему)

(function() {

    /**
     * Функция для показа кастомного уведомления в стиле "тоста".
     * Хорошо подходит для WebView, так как не блокирует интерфейс как alert().
     * @param {string} message - Текст сообщения.
     * @param {number} duration - Длительность показа в миллисекундах (по умолчанию 3000).
     * @param {string} type - Тип уведомления ('success', 'info', 'warning', 'error') для разного фона.
     */
    function showWebViewNotification(message, duration = 3000, type = 'success') {
        // Убедимся, что body уже загружено
        if (!document.body) {
            console.warn('[AdBlock Patch] document.body не найден, уведомление не показано.');
            return;
        }

        // 1. Создаем основной элемент уведомления
        const notification = document.createElement('div');
        notification.textContent = message.replace(/\\n/g, '\n'); // Поддержка переносов строк

        // 2. Базовые стили
        const baseStyles = {
            position: 'fixed', // Или 'absolute', если 'fixed' вызывает проблемы в старых WebView
            bottom: '20px',    // Позиция внизу экрана - более привычно для Android
            left: '50%',       // Центрируем по горизонтали
            transform: 'translateX(-50%)', // Точное центрирование
            minWidth: '180px',
            maxWidth: '90%',
            padding: '12px 20px',
            color: 'white',
            borderRadius: '25px', // Более скругленные углы
            boxShadow: '0 3px 8px rgba(0, 0, 0, 0.25)',
            zIndex: '10001', // Еще выше на всякий случай
            fontFamily: 'Roboto, Arial, sans-serif', // Roboto - стандартный шрифт Android
            fontSize: '14px',
            lineHeight: '1.4',
            textAlign: 'center',
            whiteSpace: 'pre-wrap',
            opacity: '0',
            transition: 'opacity 0.4s ease-in-out, bottom 0.4s ease-in-out', // Плавный переход
            pointerEvents: 'none' // Не мешает кликам под ним
        };

        // 3. Стили в зависимости от типа
        let backgroundColor = '#333'; // По умолчанию - темный
        switch (type) {
            case 'success': backgroundColor = '#28a745'; break; // Зеленый
            case 'info':    backgroundColor = '#17a2b8'; break; // Голубой
            case 'warning': backgroundColor = '#ffc107'; color = '#333'; break; // Желтый (темный текст)
            case 'error':   backgroundColor = '#dc3545'; break; // Красный
        }
        baseStyles.backgroundColor = backgroundColor;
        if (color) baseStyles.color = color; // Применяем цвет текста, если он был изменен (для warning)

        // Применяем все стили
        Object.assign(notification.style, baseStyles);

        // 4. Добавляем элемент на страницу
        document.body.appendChild(notification);

        // 5. Анимация появления (небольшая задержка для срабатывания transition)
        setTimeout(() => {
            notification.style.opacity = '1';
            notification.style.bottom = '30px'; // Слегка приподнимаем
        }, 50);

        // 6. Анимация исчезновения и удаление элемента
        setTimeout(() => {
            notification.style.opacity = '0';
            notification.style.bottom = '20px'; // Опускаем обратно
            // Удаляем элемент из DOM после завершения анимации
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 400); // Время должно совпадать с transition-duration
        }, duration);
    }

    // Используем новую функцию вместо alert
    showWebViewNotification('Patch Activated v0.1b\n@xrsrvd', 3000, 'success'); // Показываем 3 секунды, тип success

    let lastFoundAd = null;
    function scanForAds() {
        const closeButtons = Array.from(document.querySelectorAll('div[class="closeButtonWrapper"]'));
        closeButtons.forEach(button => {
            if (button === lastFoundAd || button.hasAttribute('data-detected')) {
                return;
            }
            button.setAttribute('data-detected', 'true');
            lastFoundAd = button;
            let adContainer = button;
            for (let i = 0; i < 3; i++) {
                if (adContainer.parentElement) {
                    adContainer = adContainer.parentElement;
                } else {
                    break;
                }
            }

            // Показываем уведомление о скрытии рекламы (если нужно)
            // showWebViewNotification('Реклама скрыта!', 2000, 'info'); // Тип info

            adContainer.style.display = 'none';
            console.log('[AdBlock Patch] Рекламный блок скрыт.');
        });
    }

    setInterval(scanForAds, 1000);

    /* // Закомментированный код для hideBanners оставлен без изменений
    function hideBanners() {
        // ... (код hideBanners) ...
    }
    //setInterval(hideBanners, 2000);
    // showWebViewNotification('Мониторинг запущен', 2500, 'info'); // Замена закомментированного alert
    */

})();
